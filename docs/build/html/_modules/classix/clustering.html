<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>classix.clustering &mdash; CLASSIX 0.0.1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/_.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> CLASSIX
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Get Started with CLASSIX</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../comparison.html">Performance Comparison</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../clustering_tutorial.html">Clustering Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../explainable_clustering.html">Explainable Clustering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../outlier_detection.html">Outlier Detection</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../clustering_parameters.html">Clustering Parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../agg_parameters.html">Aggregation Parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mg_parameters.html">Merging Parameters</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../contact.html">Contact</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../acknowledgement.html">Acknowledgement</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">CLASSIX</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>classix.clustering</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for classix.clustering</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">#</span>
<span class="c1"># CLASSIX: Fast and explainable clustering based on sorting</span>
<span class="c1">#</span>
<span class="c1"># MIT License</span>
<span class="c1">#</span>
<span class="c1"># Copyright (c) 2022 Stefan GÃ¼ttel, Xinye Chen</span>
<span class="c1">#</span>
<span class="c1"># Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="c1"># of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
<span class="c1"># in the Software without restriction, including without limitation the rights</span>
<span class="c1"># to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<span class="c1"># copies of the Software, and to permit persons to whom the Software is</span>
<span class="c1"># furnished to do so, subject to the following conditions:</span>
<span class="c1">#</span>
<span class="c1"># The above copyright notice and this permission notice shall be included in all</span>
<span class="c1"># copies or substantial portions of the Software.</span>
<span class="c1">#</span>
<span class="c1"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="c1"># IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="c1"># FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="c1"># AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="c1"># LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<span class="c1"># OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="c1"># SOFTWARE.</span>

<span class="k">try</span><span class="p">:</span>
    <span class="c1"># # %load_ext Cython</span>
    <span class="c1"># !python3 setup.py build_ext --inplace</span>
    <span class="kn">from</span> <span class="nn">.aggregation_cm</span> <span class="kn">import</span> <span class="n">aggregate</span> <span class="c1"># cython with memory view</span>
    <span class="kn">from</span> <span class="nn">.merging_cm</span> <span class="kn">import</span> <span class="o">*</span> 
<span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.aggregation</span> <span class="kn">import</span> <span class="n">aggregate</span> 
    <span class="kn">from</span> <span class="nn">.merging</span> <span class="kn">import</span> <span class="o">*</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cython fail.&quot;</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="c1">#import pyximport; pyximport.install()</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">svds</span>
<span class="c1"># from sklearn.decomposition import PCA</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_matrix</span><span class="p">,</span> <span class="n">_sparsetools</span>
<span class="c1"># from .merging import minimum_spanning_tree_agglomerate </span>
<span class="c1"># from scipy.sparse import csr_matrix</span>
<span class="c1"># from scipy.sparse.csgraph import shortest_path</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>





<span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="n">current_dir</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="n">url_parent</span> <span class="o">=</span> <span class="s2">&quot;https://github.com/nla-group/classix/raw/master/classix/data/vdu_signals.npy&quot;</span>
    <span class="n">vdu_signals</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url_parent</span><span class="p">)</span><span class="o">.</span><span class="n">content</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">current_dir</span><span class="p">,</span> <span class="s1">&#39;data/vdu_signals.npy&#39;</span><span class="p">),</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handler</span><span class="p">:</span>
        <span class="n">handler</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">vdu_signals</span><span class="p">)</span>
        

<span class="k">def</span> <span class="nf">load_data</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;vdu_signals&#39;</span><span class="p">):</span>
    <span class="n">current_dir</span><span class="p">,</span> <span class="n">current_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;vdu_signals&#39;</span><span class="p">:</span>
        <span class="n">DATA_PATH</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">current_dir</span><span class="p">,</span> <span class="s1">&#39;data/vdu_signals.npy&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">DATA_PATH</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">current_dir</span><span class="p">,</span> <span class="s1">&#39;data/&#39;</span><span class="p">))</span>
            <span class="n">get_data</span><span class="p">(</span><span class="n">current_dir</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">DATA_PATH</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Currently not support this data.&quot;</span><span class="p">)</span>

        
        
<span class="c1"># ******************************************** the main wrapper ********************************************</span>
<div class="viewcode-block" id="CLASSIX"><a class="viewcode-back" href="../../clustering_parameters.html#classix.clustering.CLASSIX">[docs]</a><span class="k">class</span> <span class="nc">CLASSIX</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;CLASSIX: Fast and explainable clustering based on sorting.</span>
<span class="sd">    </span>
<span class="sd">    The user only need to concern the hyperparameters of ``sorting&#39;&#39;, ``radius&#39;&#39;, and ``minPts&#39;&#39; in the most cases.</span>
<span class="sd">    If want a flexible clustering, might consider other hyperparameters such as ``group_merging&#39;&#39;, ``scale&#39;&#39;, and ``post_alloc&#39;&#39;.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sorting : str, {&#39;pca&#39;, &#39;norm-mean&#39;, &#39;norm-orthant&#39;, None}ï¼default=&#39;pca&#39;</span>
<span class="sd">        Sorting method used for the aggregation phase.</span>
<span class="sd">        </span>
<span class="sd">        - &#39;pca&#39;: sort data points by their first principal component</span>
<span class="sd">        </span>
<span class="sd">        - &#39;norm-mean&#39;: shift data to have zero mean and then sort by 2-norm values</span>
<span class="sd">        </span>
<span class="sd">        - &#39;norm-orthant&#39;: shift data to positive orthant and then sort by 2-norm values</span>
<span class="sd">        </span>
<span class="sd">        - None: aggregate the raw data without any sorting</span>
<span class="sd">        </span>
<span class="sd">    radius : float, default=0.5</span>
<span class="sd">        Tolerance to control the aggregation. If the distance between a starting point </span>
<span class="sd">        and an object is less than or equal to the tolerance, the object will be allocated </span>
<span class="sd">        to the group which the starting point belongs to. For details, we refer users to [1].</span>
<span class="sd">    </span>
<span class="sd">    group_merging : str, {&#39;density&#39;, &#39;distance&#39;}, default=&#39;distance&#39;</span>
<span class="sd">        The method for merging the groups. </span>
<span class="sd">        </span>
<span class="sd">        - &#39;density&#39;: two groups are merged if the density of data points in their intersection </span>
<span class="sd">           is at least as high the smaller density of both groups. This option uses the disjoint </span>
<span class="sd">           set structure to speedup agglomerate.</span>
<span class="sd">        </span>
<span class="sd">        - &#39;distance&#39;: two groups are merged if the distance of their starting points is at </span>
<span class="sd">           most scale*radius (the parameter above). This option uses the disjoint </span>
<span class="sd">           set structure to speedup agglomerate.</span>
<span class="sd">        </span>
<span class="sd">        For more details, we refer to [1].</span>
<span class="sd">    </span>
<span class="sd">    minPts : int, default=0</span>
<span class="sd">        Clusters with less than minPts points are classified as abnormal clusters.  </span>
<span class="sd">        The data points in an abnormal cluster will be redistributed to the nearest normal cluster. </span>
<span class="sd">        When set to 0, no redistribution is performed. </span>
<span class="sd">    </span>
<span class="sd">    norm : boolean, default=True</span>
<span class="sd">        If normalize the data associated with the sorting, default as True. </span>
<span class="sd">        </span>
<span class="sd">    scale : float</span>
<span class="sd">        Design for distance-clustering, when distance between the two starting points </span>
<span class="sd">        associated with two distinct groups smaller than scale*radius, then the two groups merge.</span>

<span class="sd">    post_alloc : boolean, default=True</span>
<span class="sd">        If allocate the outliers to the closest groups, hence the corresponding clusters. </span>
<span class="sd">        If False, all outliers will be labeled as -1.</span>
<span class="sd">    </span>

<span class="sd">    verbose : boolean or int, default=1</span>
<span class="sd">        Whether print the logs or not.</span>
<span class="sd">             </span>
<span class="sd">             </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    agg_labels : numpy.ndarray</span>
<span class="sd">        Groups labels of aggregation.</span>
<span class="sd">    </span>
<span class="sd">    splist : numpy.ndarray</span>
<span class="sd">        List of starting points formed in the aggregation.</span>
<span class="sd">        </span>
<span class="sd">    labels_ : list</span>
<span class="sd">        Clustering class labels for data objects </span>

<span class="sd">    group_outliers : numpy.ndarray</span>
<span class="sd">        Indices of outliers (aggregation groups level), </span>
<span class="sd">        i.e., indices of abnormal groups within the clusters with fewer </span>
<span class="sd">        data points than minPts points.</span>
<span class="sd">        </span>
<span class="sd">    clean_index :</span>
<span class="sd">        The data without outliers. Given data X,  the data without outliers </span>
<span class="sd">        can be exported by X_clean = X[classix.clean_index,:] while the outliers can be exported by </span>
<span class="sd">        Outliers = X[~classix.clean_index,:] </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    Methods:</span>
<span class="sd">    ----------</span>
<span class="sd">    fit(data):</span>
<span class="sd">        Cluster data while the parameters of the model will be saved. The labels can be extracted by calling &#39;.labels_&#39;</span>
<span class="sd">        </span>
<span class="sd">    fit_transform(data):</span>
<span class="sd">        Cluster data and return labels. The labels can also be extracted by calling &#39;.labels_&#39;</span>
<span class="sd">        </span>
<span class="sd">    predict(data):</span>
<span class="sd">        After clustering the in-sample data, predict the out-sample data.</span>
<span class="sd">        Data will be allocated to the clusters with the nearest starting point in the stage of aggregation. Default values.</span>
<span class="sd">        </span>
<span class="sd">    explain(index1, index2): </span>
<span class="sd">        Explain the computed clustering. </span>
<span class="sd">        The indices index1 and index2 are optional parameters (int) corresponding to the </span>
<span class="sd">        indices of the data points. </span>
<span class="sd">        </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] X. Chen and S. GÃ¼ttel. Fast and explainable sorted based clustering, 2022</span>
<span class="sd">    &quot;&quot;&quot;</span>
        
    <span class="c1"># deprecated descriptions</span>
    <span class="c1"># group_merging : str, {&#39;density&#39;, &#39;distance&#39;, &#39;scc-distance&#39;, &#39;mst-distance&#39;}, default=&#39;distance&#39;</span>
    <span class="c1">#     The method for merging the groups. </span>
    <span class="c1">#     - &#39;density&#39;: two groups are merged if the density of data points in their intersection </span>
    <span class="c1">#        is at least as high the smaller density of both groups. This option uses the disjoint </span>
    <span class="c1">#        set structure to speedup agglomerate.</span>
    <span class="c1">#     - &#39;distance&#39;: two groups are merged if the distance of their starting points is at </span>
    <span class="c1">#        most scale*radius (the parameter above). This option uses the disjoint </span>
    <span class="c1">#        set structure to speedup agglomerate.</span>
    <span class="c1">#     - &#39;scc-distance&#39;: calculate the distance-based merging by Tarjan&#39;s algorithm for finding</span>
    <span class="c1">#        strongly connected components.</span>
    <span class="c1">#     - &#39;mst-distance&#39;: it is also a distance based group_merging, but use minimum spanning tree instead</span>
    <span class="c1">#        in the second stage with cutoff_scale scale*radius.</span>
    <span class="c1"># n_jobs : int, default=-1</span>
    <span class="c1">#     This parameter only works for method called &#39;scc-distance&#39;, which refers to the</span>
    <span class="c1">#     number of jobs to use for the computation by breaking down the pairwise matrix into n_jobs </span>
    <span class="c1">#     even slices and computing them in parallel.</span>
        
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sorting</span><span class="o">=</span><span class="s2">&quot;pca&quot;</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">minPts</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group_merging</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">post_alloc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span> 
        <span class="c1"># deprecated parameter (15/07/2021): noise_percent=0, distance_scale=1, eta=1, cython=True</span>
        <span class="c1"># eta (deprecated): float, default=1.0</span>
        <span class="c1">#     the value for the density-based groups merging, the groups will </span>
        <span class="c1">#     merge together if their starting points p1 and p2 satisy both:</span>
        <span class="c1">#     (1) &quot;density in of intersection between p1 or p2 * eta &lt; density in p1&quot; and &quot;density in of intersection between p1 and p2 * eta &lt;     density in p2&quot;</span>
        <span class="c1">#     (2) &quot;distance between p1 and p1&quot; &lt; 2*radius (tolerance)</span>
        <span class="c1"># </span>
        <span class="c1"># if distance_scale &gt; 1 and group_merging == &quot;density&quot;: # since there is no intersection.</span>
        <span class="c1">#     raise ValueError(</span>
        <span class="c1">#         &quot;Please feed an correct value for distance_scale for density group merging.&quot;)</span>
        <span class="c1"># </span>
        <span class="c1"># distance_scale (deprecated): float, default=1.0</span>
        <span class="c1">#     The value for the distance-based groups merging, the groups will </span>
        <span class="c1">#     merge together if their starting points  distance is less than or equal to 2*distance_scale*radius (tolerance)</span>
        <span class="c1">#     The higher it is, the higher possibility the groups will merge together.</span>
        <span class="c1">#     *Note that for density group merging, distance_scale can not be higher than 1, otherwise there is no intersection between two groups.</span>
        <span class="c1">#   </span>
        <span class="c1"># noise_percent (deprecated): int, default=50</span>
        <span class="c1">#     The threshold, in the range of [0,100) to determine the noise degree.</span>
        <span class="c1">#     Decide &#39;noise_percent&#39; percentile of the number of data in clusters as outliers threshold. </span>
        <span class="c1">#     The intuition is that if the number of the objects in a cluster is very small, </span>
        <span class="c1">#     the cluster is very likely to be a abnormal cluster.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="c1"># self.noise_percent = noise_percent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minPts</span> <span class="o">=</span> <span class="n">minPts</span>

        <span class="c1"># if self.minPts == 0:</span>
        <span class="c1">#     if self.verbose:</span>
        <span class="c1">#         print(&quot;No anomaly detection setting.&quot;)</span>
        <span class="c1"># else:</span>
        <span class="c1">#     if self.verbose:</span>
        <span class="c1">#        print(&quot;Noises check with minPts:{:.6f}&quot;.format(minPts))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sorting</span> <span class="o">=</span> <span class="n">sorting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group_merging</span> <span class="o">=</span> <span class="n">group_merging</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sp_to_c_info</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># combine with visualization and data analysis, ensure call PCA and form groups information table only once</span>
        <span class="c1"># self.cython = cython</span>
        <span class="c1"># self.eta = eta</span>
        <span class="c1"># self.distance_scale = distance_scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">norm</span> <span class="c1"># usually, we do not use this parameter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span> <span class="c1"># For distance measure, usually, we do not use this parameter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">post_alloc</span> <span class="o">=</span> <span class="n">post_alloc</span>
        <span class="c1"># self.n_jobs = n_jobs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clean_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connected_pairs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_color</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">splist_indices</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
            
            
<div class="viewcode-block" id="CLASSIX.fit"><a class="viewcode-back" href="../../clustering_parameters.html#classix.clustering.CLASSIX.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Cluster the data.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : numpy.ndarray</span>
<span class="sd">            The ndarray-like input of shape (n_samples,)</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span>  <span class="s1">&#39;float64&#39;</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorting</span> <span class="o">==</span> <span class="s2">&quot;norm-mean&quot;</span><span class="p">:</span>
                <span class="c1"># self._mu, self._std = data.mean(axis=0), data.std()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mu</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mu</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorting</span> <span class="o">==</span> <span class="s2">&quot;pca&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mu</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mu</span> <span class="c1"># mean center</span>
                <span class="n">rds</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># distance of each data point from 0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">rds</span><span class="p">)</span> <span class="c1"># 50% of data points are within that radius</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span> <span class="c1"># now 50% of data are in unit ball </span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorting</span> <span class="o">==</span> <span class="s2">&quot;norm-orthant&quot;</span><span class="p">:</span>
                <span class="c1"># self._mu, self._std = data.min(axis=0), data.std()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mu</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mu</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># self._mu, self._std = data.mean(axis=0), data.std(axis=0) # z-score</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="c1"># no normalization</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mu</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mu</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span> <span class="o">=</span> <span class="mi">1</span>
            
        <span class="c1"># aggregation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">agg_labels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="p">,</span>  <span class="bp">self</span><span class="o">.</span><span class="n">dist_nr</span> <span class="o">=</span> <span class="n">aggregate</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">sorting</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sorting</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">splist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">clean_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span> <span class="c1"># claim clean data indices</span>
        <span class="c1"># clustering</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clustering</span><span class="p">(</span>
                            <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> 
                            <span class="n">agg_labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">agg_labels</span><span class="p">,</span> 
                            <span class="n">splist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="p">,</span> 
                            <span class="n">sorting</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sorting</span><span class="p">,</span> 
                            <span class="n">radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> 
                            <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">group_merging</span><span class="p">,</span> <span class="c1"># eta=self.eta, distance_scale=self.distance_scale, </span>
                            <span class="n">minPts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">minPts</span> <span class="c1"># percent=self.noise_percent, noise_scale=self.noise_scale,</span>
        <span class="p">)</span> 
        <span class="k">return</span> <span class="bp">self</span></div>


        
<div class="viewcode-block" id="CLASSIX.fit_transform"><a class="viewcode-back" href="../../clustering_parameters.html#classix.clustering.CLASSIX.fit_transform">[docs]</a>    <span class="k">def</span> <span class="nf">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Cluster the data and return the associated cluster labels. </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : numpy.ndarray</span>
<span class="sd">            The ndarray-like input of shape (n_samples,)</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        labels_ : numpy.ndarray</span>
<span class="sd">            The clustering labels.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span>  <span class="s1">&#39;float64&#39;</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>    
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorting</span> <span class="o">==</span> <span class="s2">&quot;norm-mean&quot;</span><span class="p">:</span>
            <span class="c1"># self._mu, self._std = data.mean(axis=0), data.std()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mu</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mu</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># prevent zero-division</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span>
        
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorting</span> <span class="o">==</span> <span class="s2">&quot;pca&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mu</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mu</span> <span class="c1"># mean center</span>
            <span class="n">rds</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># distance of each data point from 0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">rds</span><span class="p">)</span> <span class="c1"># 50% of data points are within that radius</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># prevent zero-division</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span> <span class="c1"># now 50% of data are in unit ball </span>
            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorting</span> <span class="o">==</span> <span class="s2">&quot;norm-orthant&quot;</span><span class="p">:</span>
            <span class="c1"># self._mu, self._std = data.min(axis=0), data.std()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mu</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mu</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># prevent zero-division</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># self._mu, self._std = data.mean(axis=0), data.std(axis=0) # z-score</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="c1"># no normalization</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mu</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span>
        
        <span class="c1"># aggregation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">agg_labels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_nr</span> <span class="o">=</span> <span class="n">aggregate</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">sorting</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sorting</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">splist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">clean_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span> <span class="c1"># claim clean data indices</span>
        <span class="c1"># clustering</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clustering</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">agg_labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">agg_labels</span><span class="p">,</span> 
            <span class="n">splist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="p">,</span>             
            <span class="n">sorting</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sorting</span><span class="p">,</span> 
            <span class="n">radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> 
            <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">group_merging</span><span class="p">,</span> <span class="c1"># eta=self.eta, distance_scale=self.distance_scale, </span>
            <span class="n">minPts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">minPts</span> <span class="c1"># percent=self.noise_percent, noise_scale=self.noise_scale,</span>
        <span class="p">)</span> 
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_</span></div>
        
        
        
<div class="viewcode-block" id="CLASSIX.predict"><a class="viewcode-back" href="../../clustering_parameters.html#classix.clustering.CLASSIX.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allocate the data to their nearest clusters.</span>
<span class="sd">        </span>
<span class="sd">        data : numpy.ndarray</span>
<span class="sd">            The ndarray-like input of shape (n_samples,)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        labels : numpy.ndarray</span>
<span class="sd">            The predicted clustering labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># deprecated documentation (24/07/2021):    </span>
        <span class="c1"># </span>
        <span class="c1"># method : str, {&#39;centers&#39;, &#39;agg_centers&#39;, &#39;agg_sps&#39;}, default=&#39;agg_centers&#39;</span>
        <span class="c1">#     the way chosen for data been allocated to the corresponding way. </span>
        <span class="c1"># </span>
        <span class="c1">#     1) &#39;centers&#39;: data will be allocated to the clusters with the nearest center. </span>
        <span class="c1">#     May lead to misallocation</span>
        <span class="c1"># </span>
        <span class="c1">#     2) &#39;agg_centers&#39;: data will be allocated to the clusters with the nearest center</span>
        <span class="c1">#     in the stage of aggregation.  May lead to misallocation</span>
        <span class="c1">#     </span>
        <span class="c1">#     3) &#39;agg_sps&#39;: data will be allocated to the clusters with the nearest starting point </span>
        <span class="c1">#     in the stage of aggregation. Default values (Recommended).</span>
            
        <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        
        <span class="c1"># if method == &quot;agg_centers&quot;:</span>
        <span class="c1">#     agg_centers = self.calculate_group_centers(self.data, self.labels_)</span>
        <span class="c1">#     data = (data - self._mu) / self._std</span>
        <span class="c1">#     for i in range(len(data)):</span>
        <span class="c1">#         agglabel = np.argmin(np.linalg.norm(agg_centers[:,3:] - data[i], axis=1, ord=2))</span>
        <span class="c1">#         labels.append(self.label_change[agglabel])</span>
                
        <span class="c1"># elif method == &quot;centers&quot;: # may lead to misallocation! avoid using it</span>
        <span class="c1">#     for i in range(len(data)):</span>
        <span class="c1">#         labels.append(np.argmin(np.linalg.norm(self.centers - data[i], axis=1, ord=2)))</span>

        <span class="c1"># elif method == &quot;agg_sps&quot;: </span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mu</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="n">splabel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="p">[:,</span><span class="mi">3</span><span class="p">:]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label_change</span><span class="p">[</span><span class="n">splabel</span><span class="p">])</span>

        <span class="c1"># else:</span>
        <span class="c1">#     raise ValueError(&quot;Please refer to an correct value for &#39;group_merging&#39;&quot;)</span>
            
        <span class="k">return</span> <span class="n">labels</span></div>
    
    
    
<div class="viewcode-block" id="CLASSIX.clustering"><a class="viewcode-back" href="../../clustering_parameters.html#classix.clustering.CLASSIX.clustering">[docs]</a>    <span class="k">def</span> <span class="nf">clustering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">agg_labels</span><span class="p">,</span> <span class="n">splist</span><span class="p">,</span> <span class="n">sorting</span><span class="o">=</span><span class="s2">&quot;pca&quot;</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span> <span class="n">minPts</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge groups after aggregation. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : numpy.ndarray</span>
<span class="sd">            The input that is array-like of shape (n_samples,).</span>
<span class="sd">        </span>
<span class="sd">        agg_labels: numpy.ndarray</span>
<span class="sd">            Groups labels of aggregation.</span>
<span class="sd">        </span>
<span class="sd">        splist: numpy.ndarray</span>
<span class="sd">            List formed in the aggregation storing starting points.</span>
<span class="sd">        </span>
<span class="sd">        sorting : str</span>
<span class="sd">            The sorting way refered for aggregation, </span>
<span class="sd">            default=&#39;pca&#39;, other options: &#39;norm-mean&#39;, &#39;norm-orthant&#39;, &#39;z-pca&#39;, or None.</span>
<span class="sd">        </span>
<span class="sd">        radius : float, default=0.5</span>
<span class="sd">            Tolerance to control the aggregation hence the whole clustering process. For aggregation, </span>
<span class="sd">            if the distance between a starting point and an object is less than or equal to the tolerance, </span>
<span class="sd">            the object will be allocated to the group which the starting point belongs to. </span>
<span class="sd">        </span>
<span class="sd">        method : str</span>
<span class="sd">            The method for groups merging, </span>
<span class="sd">            default=&#39;distance&#39;, other options: &#39;density&#39;, &#39;mst-distance&#39;, and &#39;scc-distance&#39;.</span>

<span class="sd">        minPts : int, default=0</span>
<span class="sd">            The threshold, in the range of [0, infity] to determine the noise degree.</span>
<span class="sd">            When assgin it 0, algorithm won&#39;t check noises.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        centers : numpy.ndarray</span>
<span class="sd">            The return centers of clusters</span>
<span class="sd">        </span>
<span class="sd">        clabels : numpy.ndarray </span>
<span class="sd">            The clusters labels of the data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># deprecated (24/07/2021):    </span>
        <span class="c1"># (optional)</span>
        <span class="c1"># eta : float, default=1.0</span>
        <span class="c1">#     the value for the density-based groups merging, the groups will </span>
        <span class="c1">#     merge together if their starting points p1 and p2 satisy both:</span>
        <span class="c1">#    (1) &quot;density in of intersection between p1 or p2 * eta &lt; density in p1&quot; and &quot;density in of intersection between p1 and p2 * eta &lt; density in p2&quot;</span>
        <span class="c1">#    (2) &quot;distance between p1 and p1&quot; &lt; 2*radius (tolerance)</span>
        <span class="c1">#</span>
        <span class="c1"># distance_scale : float, default=1.0</span>
        <span class="c1">#    the value for the distance-based groups merging, the groups will </span>
        <span class="c1">#    merge together if their starting points  distance is less than or equal to 2*distance_scale*radius (tolerance)</span>
        <span class="c1">#    The higher it is, the higher possibility the groups will merge together.</span>
        <span class="c1">#    *Note that for density method, distance_scale can not be higher than 1, otherwise there is no intersection between two groups.</span>
            
        <span class="c1"># percent : int, default=50</span>
        <span class="c1">#     The threshold, in the range of [0,100) to determine the noise degree.</span>
        <span class="c1">#     Decide &#39;percent&#39; percentile of the number of data in clusters as outliers threshold. </span>
        <span class="c1">#     The intuition is that if the number of the objects in a cluster is very small, </span>
        <span class="c1">#     the cluster is very likely to be a abnormal cluster.</span>
        
        <span class="c1"># try:</span>
            <span class="c1"># from .cagg import aggregate</span>
            <span class="c1"># # %load_ext Cython</span>
            <span class="c1"># !python3 setup.py build_ext --inplace</span>
        <span class="c1">#     from .cagg_memview import aggregate # memory view</span>
        <span class="c1"># except ModuleNotFoundError:</span>
        <span class="c1">#     from .agg import aggregate</span>

        <span class="c1"># print(&quot;aggregation initialize...&quot;)</span>
        <span class="c1"># if isinstance(data, pd.core.frame.DataFrame):</span>
        <span class="c1">#     data = data.values</span>
        <span class="c1">#     if len(data.values.shape) == 1:</span>
        <span class="c1">#         data = data.reshape(-1,1)</span>
                
        <span class="c1"># if sorting == &quot;pca&quot;: # mean-shift normalization + pca sorting</span>
            <span class="c1"># data, parameters = self.normalize(data, shift=&#39;mean&#39;)</span>
        <span class="c1">#     labels, splist, self.dist_c = aggregate(data=data, sorting=sorting, tol=radius)</span>
        <span class="c1"># elif sorting == &quot;norm-mean&quot;: # mean-shift normalization + norm sorting</span>
            <span class="c1"># data, parameters = self.normalize(data, shift=&#39;mean&#39;)</span>
        <span class="c1">#     labels, splist, self.dist_c = aggregate(data=data, sorting=sorting, tol=radius)</span>
        <span class="c1"># elif sorting == &quot;norm-orthant&quot;: # min-shift normalization + norm sorting</span>
            <span class="c1"># data, parameters = self.normalize(data, shift=&#39;min&#39;)</span>
        <span class="c1">#     labels, splist, self.dist_c = aggregate(data=data, sorting=sorting, tol=radius)</span>
        <span class="c1"># elif sorting == &quot;z-pca&quot;: # z-score normalization + pca sorting</span>
            <span class="c1"># data, parameters = self.normalize(data, shift=&#39;z-score&#39;)</span>
        <span class="c1">#    labels, splist, self.dist_c = aggregate(data=data, sorting=&quot;pca&quot;, tol=radius)</span>
        <span class="c1"># else: # z-score normalization without sorting</span>
            <span class="c1"># data, parameters = self.normalize(data, shift=&#39;z-score&#39;)</span>
        <span class="c1">#     labels, splist, self.dist_c = aggregate(data=data, sorting=sorting, tol=radius)     </span>
        

        <span class="c1">#print(&#39;splist:\n&#39;, splist)</span>
        <span class="c1"># labels = np.array(labels)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">agg_labels</span><span class="p">)</span> 
        
        <span class="c1"># calculate the overall volume of the combination of the clusters,</span>
        <span class="c1"># hence only compare their neighbor clusters</span>
        <span class="c1"># if method == &quot;mst-distance&quot;:</span>
        <span class="c1">#     self.merge_groups = minimum_spanning_tree_agglomerate(splist, radius=radius, scale=self.scale)</span>
        <span class="c1"># </span>
        <span class="c1"># elif method == &#39;scc-distance&#39;:</span>
        <span class="c1">#     self.merge_groups = scc_agglomerate(splist, radius=radius, scale=self.scale, n_jobs=self.n_jobs)</span>
        
        <span class="c1"># --Deprecated </span>
        <span class="c1"># elif method == &#39;trivial-distance&#39;: # deprecated method: brute force</span>
        <span class="c1">#     self.connected_pairs = agglomerate_trivial(data, splist, radius, &quot;distance&quot;, scale=self.scale)</span>
            <span class="c1"># self.check_labels = labels</span>
            <span class="c1"># reassign lalels, start from 0, since the cluster number not start with 0.</span>

            <span class="c1"># we employ an intutive and simple way to implement merging groups, resulting in a fast clustering</span>
            <span class="c1"># self.merge_groups = merge_pairs_dr(self.connected_pairs)</span>
        
        <span class="c1"># elif method == &#39;trivial-density&#39;: # deprecated method: brute force</span>
            <span class="c1"># self.connected_pairs = agglomerate_trivial(data, splist, radius, &quot;density&quot;, scale=self.scale)</span>
            <span class="c1"># self.check_labels = labels</span>
            <span class="c1"># reassign lalels, start from 0, since the cluster number not start with 0.</span>

            <span class="c1"># we employ an intutive and simple way to implement merging groups, resulting in a fast clustering</span>
            <span class="c1"># self.merge_groups = merge_pairs_dr(self.connected_pairs)</span>
        
        <span class="c1"># else:</span>
            <span class="c1"># print(&quot;clusters merging initialize...&quot;)</span>
            <span class="c1"># self.merge_groups, self.connected_pairs = fast_agglomerate(data, splist, radius, method, scale=self.scale)</span>
            <span class="c1"># self.check_labels = labels</span>
            <span class="c1"># reassign lalels, start from 0, since the cluster number not start with 0.</span>

            <span class="c1"># we employ an intutive and simple way to implement merging groups, resulting in a fast clustering</span>
            <span class="c1"># self.merge_groups = merge_pairs(self.connected_pairs)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">merge_groups</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected_pairs</span> <span class="o">=</span> <span class="n">fast_agglomerate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">splist</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
        <span class="n">maxid</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        
        <span class="c1"># after this step, the connected pairs (groups) will be transformed into merged clusters, </span>
        <span class="k">for</span> <span class="n">sublabels</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_groups</span><span class="p">:</span> <span class="c1"># some of aggregated groups might be independent which are not included in self.merge_groups</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">sublabels</span><span class="p">:</span>
                <span class="n">labels</span><span class="p">[</span><span class="n">labels</span> <span class="o">==</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">maxid</span>
            <span class="n">maxid</span> <span class="o">=</span> <span class="n">maxid</span> <span class="o">+</span> <span class="mi">1</span>
        
        <span class="c1"># but the existent clusters may have some very independent clusters which are possibly be &quot;noise&quot; clusters.</span>
        <span class="c1"># so the next step is extracting the clusters with very rare number of objects as potential &quot;noises&quot;.</span>
        <span class="c1"># we calculate the percentiles of the number of clusters objects. For example, given the dataset size of 100,</span>
        <span class="c1"># there are 4 clusters, the associated number of objects inside clusters are repectively of 5, 20, 25, 50. </span>
        <span class="c1"># The 10th percentlie (we set percent=10, noise_scale=0.1) of (5, 20, 25, 50) is 14, </span>
        <span class="c1"># and we calculate threshold = 100 * noise_scale =  10. Obviously, the first cluster with number of objects 5</span>
        <span class="c1"># satisfies both condition 5 &lt; 14 and 5 &lt; 10, so we classify the objects inside first cluster as outlier.</span>
        <span class="c1"># And then we allocate the objects inside the outlier cluster into other closest cluster.</span>
        <span class="c1"># This method is quite effective at solving the noise arise from small tolerance (radius).</span>
        

        <span class="bp">self</span><span class="o">.</span><span class="n">old_cluster_count</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">minPts</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">potential_noise_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outlier_filter</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="n">minPts</span><span class="p">)</span> <span class="c1"># calculate the min_samples directly</span>
            <span class="n">SIZE_NOISE_LABELS</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">potential_noise_labels</span><span class="p">)</span> 
            <span class="k">if</span> <span class="n">SIZE_NOISE_LABELS</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Setting of noise related parameters is not correct, degenerate to the method without noises dectection.&quot;</span><span class="p">,</span> 
                <span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">potential_noise_labels</span><span class="p">):</span>
                    <span class="n">labels</span><span class="p">[</span><span class="n">labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">maxid</span> <span class="c1"># marked as noises, </span>
                                                <span class="c1"># the label number is not included in any of existing labels (maxid).</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">potential_noise_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="n">SIZE_NOISE_LABELS</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># remove noise cluster, avoid connecting two separate to a single cluster</span>
        <span class="c1">#---------------------------------------------------------------------------------------------------------</span>
        <span class="c1"># if minPts &gt;= 1:</span>
        <span class="c1">#     possible_noise_labels = self.noises_filter(labels, min_samples=minPts) # calculate the min_samples directly</span>
        <span class="c1"># else: </span>
        <span class="c1">#     possible_noise_labels = self.noises_filter(labels, min_samples_rate=minPts) # calculate the min_samples as minPts*data.shape[0]</span>
        <span class="c1">#---------------------------------------------------------------------------------------------------------</span>
        

        
        <span class="c1"># label_return_noises = copy.deepcopy(labels) # all noises are marked as maxid, similar to DBSCAN return noises.</span>
        <span class="c1"># the label with the maxid is label marked noises</span>

        <span class="c1"># the following is centers calculation step, which is not our current concern</span>
        <span class="c1"># centers = np.zeros((0, data.shape[1]))</span>
        
        <span class="c1"># self.outliers = np.array([]) # abnormal groups from aggregation</span>
        
        <span class="k">if</span> <span class="n">SIZE_NOISE_LABELS</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># noise_id = max(labels)</span>
            <span class="c1"># pure_labels = [i for i in np.unique(labels) if i != maxid]</span>
            <span class="c1"># self.outliers = np.where(labels == maxid)[0]</span>
            <span class="c1"># self.ne_outliers = np.where(labels != maxid)[0]</span>
            
            <span class="c1"># assign outliers in terms of group level</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clean_index</span> <span class="o">=</span> <span class="n">labels</span> <span class="o">!=</span> <span class="n">maxid</span>
            <span class="n">agln</span> <span class="o">=</span> <span class="n">agg_labels</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">clean_index</span><span class="p">]</span>
            <span class="c1"># agg_clean_index = np.unique(agln) # extract the unique number of aggregation groups.</span>
            <span class="c1"># agg_noise_index = np.unique(self.agg_labels[self.outliers]) # extract the unique number of aggregation groups.</span>
            <span class="c1"># print(&quot;agg_clean_index:&quot;, agg_clean_index)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label_change</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">agln</span><span class="p">,</span> <span class="n">labels</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">clean_index</span><span class="p">]))</span> <span class="c1"># how object change group to cluster.</span>
            <span class="c1"># print(&quot;label change:&quot;, self.label_change)</span>
            <span class="c1"># allocate the outliers to the corresponding closest cluster.</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">group_outliers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">agg_labels</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">clean_index</span><span class="p">])</span> <span class="c1"># abnormal groups</span>
            <span class="n">unique_agln</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">agln</span><span class="p">)</span>
            <span class="n">splist_clean</span> <span class="o">=</span> <span class="n">splist</span><span class="p">[</span><span class="n">unique_agln</span><span class="p">]</span>
            <span class="c1"># splist_outliers = splist[self.group_outliers] </span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_alloc</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">nsp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_outliers</span><span class="p">:</span>
                    <span class="n">alloc_class</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">splist_clean</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:]</span> <span class="o">-</span> <span class="n">splist</span><span class="p">[</span><span class="n">nsp</span><span class="p">,</span> <span class="mi">3</span><span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
                    <span class="n">labels</span><span class="p">[</span><span class="n">agg_labels</span> <span class="o">==</span> <span class="n">nsp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_change</span><span class="p">[</span><span class="n">unique_agln</span><span class="p">[</span><span class="n">alloc_class</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">labels</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">agg_labels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_outliers</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="c1"># previous code works on the point level</span>
            <span class="c1"># ----------------------------------- old code 1-----------------------------------</span>
            <span class="c1"># self.outliers = np.where(labels == maxid)[0]</span>
            <span class="c1"># agln = agg_labels[labels != maxid]           </span>
            <span class="c1"># splist_clean = splist[np.unique(agln)]</span>
            <span class="c1"># </span>
            <span class="c1"># self.label_change = dict(zip(agln, labels[labels != maxid])) # how object change group to cluster.</span>
            <span class="c1"># if self.outliers.size &gt; 0:</span>
            <span class="c1">#     # marked outliers location, and allocate the outliers to their closest clusters.</span>
            <span class="c1">#     for i in self.outliers:</span>
            <span class="c1">#         alloc_class = np.argmin(np.linalg.norm(splist_clean[:,3:] - data[i], axis=1, ord=2))</span>
            <span class="c1">#         labels[i] = self.label_change[splist_clean[alloc_class, 1]]</span>
            <span class="c1"># -------------------------------------------------------------------------------- </span>
            
            <span class="c1"># ----------------------------------- old code 2-----------------------------------</span>
            <span class="c1"># splist_clean = splist[agg_clean_index]</span>
            <span class="c1"># print(&quot;splist_clean:&quot;, splist_clean)</span>
            <span class="c1"># if self.outliers.size &gt; 0:</span>
            <span class="c1">#     # marked outliers location, and allocate the outliers to their closest clusters.</span>
            <span class="c1">#     for i in self.outliers:</span>
            <span class="c1">#         alloc_class = np.argmin(np.linalg.norm(splist_clean[:,3:] - data[i], axis=1, ord=2))</span>
            <span class="c1">#         # print(&quot;alloc_class:&quot;, alloc_class)</span>
            <span class="c1">#         # print(&quot;labels[i]:&quot;, labels[i], &quot;change to:&quot;, self.label_change[splist_clean[alloc_class, 1]])</span>
            <span class="c1">#         labels[i] = self.label_change[splist_clean[alloc_class, 1]]</span>
            <span class="c1"># -------------------------------------------------------------------------------- </span>
            
        <span class="c1"># else:</span>
            <span class="c1"># self.outliers = np.array([])</span>
            <span class="c1"># pure_labels = np.unique(labels)</span>
           
            <span class="c1"># noise_id = -1   </span>
        
        <span class="c1"># we ensure the centers calculation does not include noises.</span>
        <span class="c1"># for c in sorted(pure_labels):</span>
        <span class="c1">#    indc = np.argwhere(labels==c)</span>
        <span class="c1">#    center = np.mean(data[indc,:], axis=0)</span>
        <span class="c1">#    centers = np.r_[ centers, center ]</span>
        
                
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reassign_labels</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">label_change</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">agg_labels</span><span class="p">,</span> <span class="n">labels</span><span class="p">))</span> <span class="c1"># how object change from group to cluster.</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;The </span><span class="si">{datalen}</span><span class="s2"> data points were aggregated into </span><span class="si">{num_group}</span><span class="s2"> groups.&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">datalen</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">num_group</span><span class="o">=</span><span class="n">splist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;In total </span><span class="si">{dist:.0f}</span><span class="s2"> comparisons were required (</span><span class="si">{avg:.2f}</span><span class="s2"> comparisons per data point). &quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_nr</span><span class="p">,</span> <span class="n">avg</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_nr</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;The </span><span class="si">{num_group}</span><span class="s2"> groups were merged into </span><span class="si">{c_size}</span><span class="s2"> clusters with the following sizes: &quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">num_group</span><span class="o">=</span><span class="n">splist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c_size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">old_cluster_count</span><span class="p">)))</span>
            <span class="c1">#print(&quot;Initialize clusters with size:&quot;)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">pprint_format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">old_cluster_count</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">minPts</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">SIZE_NOISE_LABELS</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;As MinPts is </span><span class="si">{minPts}</span><span class="s2">, the number of clusters has been further reduced to </span><span class="si">{r}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">minPts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">minPts</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>
                <span class="p">))</span>
                
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Try the .explain() method to explain the clustering.&quot;</span><span class="p">)</span>

        <span class="c1"># if self.verbose == 1:</span>
        <span class="c1">#     print(&quot;As minPts is 20, the clusters are compressed from {l} to {r}.&quot;.format(</span>
        <span class="c1">#         l=len(np.unique(agg_labels)), r=len(np.unique(labels))</span>
        <span class="c1">#     ))</span>
            
        <span class="k">return</span> <span class="n">labels</span> <span class="c1">#, centers</span></div>
    
    
    
<div class="viewcode-block" id="CLASSIX.explain"><a class="viewcode-back" href="../../clustering_parameters.html#classix.clustering.CLASSIX.explain">[docs]</a>    <span class="k">def</span> <span class="nf">explain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index1</span><span class="o">=</span><span class="s2">&quot;NULL&quot;</span><span class="p">,</span> <span class="n">index2</span><span class="o">=</span><span class="s2">&quot;NULL&quot;</span><span class="p">,</span> <span class="n">showsplist</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_colwidth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">replace_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">figstyle</span><span class="o">=</span><span class="s2">&quot;ggplot&quot;</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ind_color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">ind_marker_size</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span>
                <span class="n">sp_fcolor</span><span class="o">=</span><span class="s1">&#39;tomato&#39;</span><span class="p">,</span>  <span class="n">sp_alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">sp_pad</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sp_fontsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sp_bbox</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                <span class="n">dp_fcolor</span><span class="o">=</span><span class="s1">&#39;bisque&#39;</span><span class="p">,</span>  <span class="n">dp_alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">dp_pad</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dp_fontsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dp_bbox</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">connect_color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">cline_width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">,</span> <span class="n">figname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;pdf&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &#39;self.explain(object/index) # prints an explanation for why a point object1 is in its cluster (or an outlier)</span>
<span class="sd">        &#39;self.explain(object1/index1, object2index) # prints an explanation why object1 and object2 are either in the same or distinct clusters</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Here we unify the terminology:</span>
<span class="sd">            [-] data points</span>
<span class="sd">            [-] groups (made up of data points, formed by aggregation)</span>
<span class="sd">            [-] clusters (made up of groups)</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index1 : int or numpy.ndarray (optional)</span>
<span class="sd">            Input object1 [with index &#39;index1&#39;] for explanation.</span>
<span class="sd">        </span>
<span class="sd">        index2 : int or numpy.ndarray (optional)</span>
<span class="sd">            Input object2 [with index &#39;index2&#39;] for explanation, and compare objects [with indices &#39;index1&#39; and &#39;index2&#39;].</span>
<span class="sd">        </span>
<span class="sd">        showsplist : boolean</span>
<span class="sd">            Determine if show the starting points information, which include the number of data points (NumPts), </span>
<span class="sd">            corresponding clusters, and associated coordinates. This only applies to both index1 and index2 are &quot;NULL&quot;.</span>
<span class="sd">            Default as True. </span>
<span class="sd">        </span>
<span class="sd">        max_colwidth : int (optional)</span>
<span class="sd">            Max width to truncate each column in characters. By default, no limit.</span>
<span class="sd">            </span>
<span class="sd">        replace_name : str or list (optional)</span>
<span class="sd">            Replace the index with name. </span>
<span class="sd">            * For example: as for indices 1 and 1300 we have </span>
<span class="sd">            </span>
<span class="sd">            ``classix.explain(1, 1300, plot=False, figstyle=&quot;seaborn&quot;) # or classix.explain(obj1, obj4)``</span>
<span class="sd">            </span>
<span class="sd">            The data point 1 is in group 9 and the data point 1300 is in group 8, both of which were merged into cluster #0. </span>
<span class="sd">            These two groups are connected via groups 9 -&gt; 2 -&gt; 8.</span>
<span class="sd">            * if we specify the replace name, then the output will be</span>
<span class="sd">            </span>
<span class="sd">            ``classix.explain(1, 1300, replace_name=[&quot;Peter Meyer&quot;, &quot;Anna Fields&quot;], figstyle=&quot;seaborn&quot;)``</span>
<span class="sd">            </span>
<span class="sd">            The data point Peter Meyer is in group 9 and the data point Anna Fields is in group 8, both of which were merged into cluster #0. </span>
<span class="sd">            These two groups are connected via groups 9 -&gt; 2 -&gt; 8.</span>

<span class="sd">        plot : boolean</span>
<span class="sd">            Determine if visulize the explaination. Default as False.</span>
<span class="sd">        </span>
<span class="sd">        figsize : tuple</span>
<span class="sd">            Determine the size of visualization figure. Default as (10, 6).</span>

<span class="sd">        figstyle : str</span>
<span class="sd">            Determine the style of visualization.</span>
<span class="sd">            see reference: https://matplotlib.org/stable/gallery/style_sheets/style_sheets_reference.html</span>
<span class="sd">        </span>
<span class="sd">        savefig : boolean</span>
<span class="sd">            Determine if save figure, the figure will be saved in the folder named &quot;img&quot;.</span>
<span class="sd">        </span>
<span class="sd">        indices_color : str</span>
<span class="sd">            Color for visualization of data with indices index1 and index2. Default as &quot;k&quot;.</span>
<span class="sd">        </span>
<span class="sd">        ind_marker_size : float), optional:</span>
<span class="sd">            Size for visualization of data with indices index1 and index2.</span>
<span class="sd">    </span>
<span class="sd">        sp_fcolor : str</span>
<span class="sd">            The color marked for starting points text box. Default as &#39;tomato&#39;.</span>
<span class="sd">            </span>
<span class="sd">        sp_alpha : float</span>
<span class="sd">            The value setting for transprency of text box for starting points. Default as 0.3.</span>
<span class="sd">            </span>
<span class="sd">        sp_pad : int</span>
<span class="sd">            The size of text box for starting points. Default as 2.</span>
<span class="sd">        </span>
<span class="sd">        sp_bbox : dict</span>
<span class="sd">            Dict with properties for patches.FancyBboxPatch for starting points. Default as None.</span>
<span class="sd">    </span>
<span class="sd">        sp_fontsize : int</span>
<span class="sd">            The fontsize for text marked for starting points. Default as None.</span>
<span class="sd">    </span>
<span class="sd">        dp_fcolor : str</span>
<span class="sd">            The color marked for specified data objects text box. Default as &#39;tomato&#39;.</span>
<span class="sd">            </span>
<span class="sd">        dp_alpha : float</span>
<span class="sd">            The value setting for transprency of text box for specified data objects. Default as 0.3.</span>
<span class="sd">            </span>
<span class="sd">        dp_pad : int</span>
<span class="sd">            The size of text box for specified data objects. Default as 2.</span>
<span class="sd">            </span>
<span class="sd">        dp_bbox : dict </span>
<span class="sd">            Dict with properties for patches.FancyBboxPatch for specified data objects. Default as None.</span>
<span class="sd">        </span>
<span class="sd">        dp_fontsize : int</span>
<span class="sd">            The fontsize for text marked for specified data objects. Default as None.    </span>
<span class="sd">            </span>
<span class="sd">        color : str</span>
<span class="sd">            Color for text of starting points labels in visualization. Default as &quot;k&quot;.</span>
<span class="sd">        </span>
<span class="sd">        alpha : float</span>
<span class="sd">            Scalar or None. Default as 0.5.</span>
<span class="sd">    </span>
<span class="sd">        cline_width : float</span>
<span class="sd">            Set the patch linewidth of circle for starting points. Default as 0.5.</span>
<span class="sd">        </span>
<span class="sd">        figname : str</span>
<span class="sd">            Set the figure name for the image to be saved.</span>
<span class="sd">            </span>
<span class="sd">        fmt : str</span>
<span class="sd">            Specify the format of the image to be saved, default as &#39;pdf&#39;, other choice: png.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># deprecated (24/07/2021)</span>
        <span class="c1"># cols = [&quot;NrPts&quot;] </span>
        <span class="c1"># for i in range(self.splist.shape[1] - 2):</span>
        <span class="c1">#     cols = cols + [&quot;feat.&quot; + str(i + 1)]</span>
        
        <span class="c1"># deprecated (24/07/2021)</span>
        <span class="c1"># -----------------------------alternative method--------------------------------</span>
        <span class="c1"># if self.splist.shape[1] - 2 !=2:</span>
        <span class="c1">#     pca = PCA(n_components=2)</span>
        <span class="c1">#     x_pca = pca.fit_transform(self.splist[:, 3:])</span>
        <span class="c1">#     spdisplay = pd.DataFrame(np.hstack((self.splist[:, 0:2], x_pca)), columns=cols)</span>
        <span class="c1"># else:</span>
        <span class="c1">#     spdisplay = pd.DataFrame(self.splist[:, 1:], columns=cols)</span>
        
        <span class="c1"># -----------------------------second method--------------------------------</span>
        <span class="k">if</span> <span class="n">sp_bbox</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sp_bbox</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">sp_bbox</span><span class="p">[</span><span class="s1">&#39;facecolor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sp_fcolor</span>
            <span class="n">sp_bbox</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sp_alpha</span>
            <span class="n">sp_bbox</span><span class="p">[</span><span class="s1">&#39;pad&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sp_pad</span>
        <span class="c1"># else: sp_bbox = {&#39;facecolor&#39;: &#39;tomato&#39;, &#39;alpha&#39;: 0.2, &#39;pad&#39;: 2}</span>
        
        <span class="k">if</span> <span class="n">dp_bbox</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dp_bbox</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">dp_bbox</span><span class="p">[</span><span class="s1">&#39;facecolor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp_fcolor</span>
            <span class="n">dp_bbox</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp_alpha</span>
            <span class="n">dp_bbox</span><span class="p">[</span><span class="s1">&#39;pad&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp_pad</span>
        <span class="c1"># else: dp_bbox = {&#39;facecolor&#39;: &#39;bisque&#39;, &#39;alpha&#39;: 0.2, &#39;pad&#39;: 2}</span>
            
        <span class="k">if</span> <span class="n">dp_fontsize</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">sp_fontsize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dp_fontsize</span> <span class="o">=</span> <span class="n">sp_fontsize</span>
            
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cluster_color</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cluster_color</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;#</span><span class="si">%06X</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0xFFFFFF</span><span class="p">)</span>
                
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_to_c_info</span><span class="p">:</span> <span class="c1">#  ensure call PCA and form groups information table only once</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">form_starting_point_clusters_table</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># self.pca = PCA(n_components=2)</span>
                <span class="c1"># self.x_pca = self.pca.fit_transform(self.data)</span>
                <span class="c1"># self.s_pca = self.pca.transform(self.data[self.splist[:, 0].astype(int)])</span>
                <span class="n">scaled_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">_U</span><span class="p">,</span> <span class="n">_s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_V</span> <span class="o">=</span> <span class="n">svds</span><span class="p">(</span><span class="n">scaled_data</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">return_singular_vectors</span><span class="o">=</span><span class="s2">&quot;u&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x_pca</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">scaled_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_V</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">_s</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">s_pca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_pca</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>
                
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x_pca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">s_pca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span> <span class="c1"># self.splist[:, 3:].copy()</span>

            <span class="k">else</span><span class="p">:</span> <span class="c1"># when data is one-dimensional, no PCA transform</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x_pca</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()),</span> <span class="mi">2</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x_pca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">s_pca</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">s_pca</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span> <span class="c1"># self.splist[:, 2]</span>
                
                <span class="c1"># remove (24/07/2021):</span>
                <span class="c1"># print(&quot;This function is restricted to multidimensional (dimension greater than or equal to 2) data.&quot;)</span>
                
        <span class="k">if</span> <span class="n">index1</span> <span class="o">==</span> <span class="s2">&quot;NULL&quot;</span> <span class="ow">and</span> <span class="n">index2</span> <span class="o">!=</span> <span class="s2">&quot;NULL&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please enter a valid value for index1.&quot;</span><span class="p">)</span>
            
        <span class="c1"># pd.options.display.max_colwidth = colwidth</span>
        <span class="n">dash_line</span> <span class="o">=</span> <span class="s2">&quot;--------&quot;</span><span class="o">*</span><span class="mi">5</span> <span class="c1"># &quot;--------&quot;*(self.splist.shape[1])</span>
            
        <span class="k">if</span> <span class="n">index1</span> <span class="o">==</span> <span class="s2">&quot;NULL&quot;</span><span class="p">:</span> <span class="c1"># analyze in the general way with a global view</span>
            <span class="k">if</span> <span class="n">plot</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">explain_viz</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span> <span class="n">figstyle</span><span class="o">=</span><span class="n">figstyle</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="n">savefig</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">sp_fontsize</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">sp_bbox</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="n">fmt</span><span class="p">)</span>
                
            <span class="n">data_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">feat_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;A clustering of </span><span class="si">{length:.0f}</span><span class="s2"> data points with </span><span class="si">{dim:.0f}</span><span class="s2"> features has been performed. &quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="n">data_size</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">feat_dim</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;The radius parameter was set to </span><span class="si">{tol:.2f}</span><span class="s2"> and MinPts was set to </span><span class="si">{minPts:.0f}</span><span class="s2">. &quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">minPts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">minPts</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;As the provided data has been scaled by a factor of 1/</span><span class="si">{scl:.2f}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">data points within a radius of R=</span><span class="si">{tol:.2f}</span><span class="s2">*</span><span class="si">{scl:.2f}</span><span class="s2">=</span><span class="si">{tolscl:.2f}</span><span class="s2"> were aggregated into groups. &quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">scl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_scl</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">tolscl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_scl</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span>
            <span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;In total </span><span class="si">{dist:.0f}</span><span class="s2"> comparisons were required (</span><span class="si">{avg:.2f}</span><span class="s2"> comparisons per data point). &quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_nr</span><span class="p">,</span> <span class="n">avg</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_nr</span><span class="o">/</span><span class="n">data_size</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;This resulted in </span><span class="si">{groups:.0f}</span><span class="s2"> groups, each uniquely associated with a starting point. &quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">groups</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;These </span><span class="si">{groups:.0f}</span><span class="s2"> groups were subsequently merged into </span><span class="si">{num_clusters:.0f}</span><span class="s2"> clusters. &quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">groups</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">num_clusters</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_</span><span class="p">))))</span>
            
            <span class="k">if</span> <span class="n">showsplist</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;A list of all starting points is shown below.&quot;&quot;&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">dash_line</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_info</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">justify</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_colwidth</span><span class="o">=</span><span class="n">max_colwidth</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">dash_line</span><span class="p">)</span>       
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;In order to see a visual representation of the clustered data, use .explain(plot=True). &quot;&quot;&quot;</span><span class="p">)</span>
                
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;In order to explain the clustering of individual data points, </span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span>
                  <span class="sd">&quot;&quot;&quot;use .explain(ind1) or .explain(ind1, ind2) with indices of the data points.&quot;&quot;&quot;</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span> <span class="c1"># explain(index1)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index1</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">object1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_pca</span><span class="p">[</span><span class="n">index1</span><span class="p">]</span> <span class="c1"># self.data has been normalized</span>
                <span class="n">agg_label1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">agg_labels</span><span class="p">[</span><span class="n">index1</span><span class="p">]</span> <span class="c1"># get the group index for object1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">object1</span> <span class="o">=</span> <span class="p">(</span><span class="n">index1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mu</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span> <span class="c1"># allow for out-sample data</span>
                <span class="n">agg_label1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_pca</span> <span class="o">-</span> <span class="n">object1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span> <span class="c1"># get the group index for object1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">object1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">object1</span><span class="p">)</span>
                    
            <span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;default&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="n">figstyle</span><span class="p">)</span>
            
            
            <span class="c1"># explain one object</span>
            <span class="c1"># cluster_centers = self.calculate_group_centers(self.data, self.labels_)</span>
            <span class="c1"># print(&quot;Starting point list of {} data:&quot;.format(len(self.agg_labels)))</span>

            <span class="k">if</span> <span class="n">index2</span> <span class="o">==</span> <span class="s2">&quot;NULL&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">replace_name</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">replace_name</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">index1_name</span> <span class="o">=</span> <span class="n">replace_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">index1_name</span> <span class="o">=</span> <span class="n">replace_name</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">index1_name</span> <span class="o">=</span> <span class="n">index1</span>

                <span class="n">cluster_label1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_change</span><span class="p">[</span><span class="n">agg_label1</span><span class="p">]</span>
                <span class="n">sp_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="p">[</span><span class="n">agg_label1</span><span class="p">,</span> <span class="mi">3</span><span class="p">:]</span>
                
                <span class="k">if</span> <span class="n">plot</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="n">figstyle</span><span class="p">)</span>
                    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;axes.facecolor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;whitesmoke&#39;</span>
                    <span class="c1"># select indices</span>
                    <span class="n">x_pca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_pca</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_</span> <span class="o">==</span> <span class="n">cluster_label1</span><span class="p">]</span>
                    <span class="n">s_pca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_pca</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_info</span><span class="o">.</span><span class="n">Cluster</span> <span class="o">==</span> <span class="n">cluster_label1</span><span class="p">]</span>
                    
                    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x_pca</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x_pca</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_color</span><span class="p">[</span><span class="n">cluster_label1</span><span class="p">])</span>
                    <span class="c1"># ax.scatter(x_pca[:, 0], x_pca[:, 1], marker=&quot;*&quot;, c=&#39;pink&#39;)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">s_pca</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">s_pca</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
                
                    <span class="k">if</span> <span class="n">dp_fontsize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">object1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">object1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">index1_name</span><span class="p">),</span> <span class="n">bbox</span><span class="o">=</span><span class="n">dp_bbox</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">ind_color</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">object1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">object1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">index1_name</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">dp_fontsize</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">dp_bbox</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">ind_color</span><span class="p">)</span>
                    
                    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">object1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">object1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">ind_marker_size</span><span class="p">)</span>
                    
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s_pca</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">((</span><span class="n">s_pca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">s_pca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="n">cline_width</span><span class="p">,</span> <span class="n">clip_on</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span> <span class="n">adjustable</span><span class="o">=</span><span class="s1">&#39;datalim&#39;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">sp_fontsize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">s_pca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">s_pca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                                    <span class="n">s</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_info</span><span class="o">.</span><span class="n">Group</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_info</span><span class="o">.</span><span class="n">Cluster</span> <span class="o">==</span> <span class="n">cluster_label1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                    <span class="c1"># self.splist[self.sp_info.Cluster == cluster_label1, 1][i].astype(int).astype(str), </span>
                                    <span class="n">bbox</span><span class="o">=</span><span class="n">sp_bbox</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">s_pca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">s_pca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                                    <span class="n">s</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_info</span><span class="o">.</span><span class="n">Group</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_info</span><span class="o">.</span><span class="n">Cluster</span> <span class="o">==</span> <span class="n">cluster_label1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                    <span class="c1"># self.splist[self.sp_info.Cluster == cluster_label1, 1][i].astype(int).astype(str), </span>
                                    <span class="n">fontsize</span><span class="o">=</span><span class="n">sp_fontsize</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">sp_bbox</span>
                            <span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span> <span class="c1"># the axis here may not be consistent, so hide.</span>
                    <span class="k">if</span> <span class="n">savefig</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s2">&quot;img&quot;</span><span class="p">):</span>
                            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="s2">&quot;img&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">&#39;pdf&#39;</span><span class="p">:</span>
                            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;img/&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">figname</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">index1</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39;.pdf&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">&#39;png&#39;</span><span class="p">:</span>
                            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;img/&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">figname</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">index1</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39;.png&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;img/&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">figname</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">index1</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">fmt</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;successfully save&quot;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
                    
                    <span class="c1"># deprecated (24/07/2021):</span>
                    <span class="c1"># if self.data.shape[1] != 2:</span>
                    <span class="c1">#     pca = PCA(n_components=2)</span>
                    <span class="c1">#     x_pca = pca.fit_transform(self.data)</span>
                    <span class="c1">#     s_pca = pca.transform(self.splist[:, 3:])</span>
                    <span class="c1">#     </span>
                    <span class="c1">#     # select indices</span>
                    <span class="c1">#     x_pca = x_pca[self.labels_ == cluster_label1]</span>
                    <span class="c1">#     s_pca = s_pca[self.sp_info.Cluster == cluster_label1]</span>
                    <span class="c1">#     </span>
                    <span class="c1">#     ax.scatter(x_pca[:, 0], x_pca[:, 1],</span>
                    <span class="c1">#                 marker=&quot;*&quot;, c=self.labels_[self.labels_ == cluster_label1])</span>
                    <span class="c1">#     ax.scatter(s_pca[:,0], s_pca[:,1], marker=&quot;p&quot;)</span>
                    <span class="c1">#     </span>
                    <span class="c1">#     ax.scatter(object1[0],  object1[1], marker=&quot;*&quot;, s=ind_marker_size)</span>
                    <span class="c1">#     ax.text(object1[0], object1[1], s=str(index1), color=ind_color)</span>
                    <span class="c1">#     </span>
                    <span class="c1">#     for i in range(s_pca.shape[0]):</span>
                    <span class="c1">#         ax.add_patch(plt.Circle((s_pca[i, 0], s_pca[i, 1]), self.radius, fill=False, color=color, alpha=alpha, lw=cline_width, clip_on=False))</span>
                    <span class="c1">#         ax.set_aspect(&#39;equal&#39;, adjustable=&#39;datalim&#39;)</span>
                    <span class="c1">#         ax.text(s_pca[i, 0], s_pca[i, 1],</span>
                    <span class="c1">#                  s=self.splist[self.sp_info.Cluster == cluster_label1,1][i].astype(int).astype(str), </span>
                    <span class="c1">#                  bbox=sp_bbox)</span>
                    <span class="c1">#     ax.plot()</span>
                    <span class="c1">#     if savefig:</span>
                    <span class="c1">#         if not os.path.exists(&quot;img&quot;):</span>
                    <span class="c1">#             os.mkdir(&quot;img&quot;)</span>
                    <span class="c1">#             plt.savefig(&#39;img/ind1.pdf&#39;)</span>
                    <span class="c1">#             print(&quot;successfully save&quot;)</span>
                    <span class="c1">#     plt.show()</span>
                        
                    <span class="c1"># elif self.data.shape[1] == 2:</span>
                    <span class="c1">#     x_pca = self.data.copy()</span>
                    <span class="c1">#     s_pca = self.splist[:, 3:].copy()</span>
                    <span class="c1">#     </span>
                    <span class="c1">#     # select indices</span>
                    <span class="c1">#     x_pca = x_pca[self.labels_ == cluster_label1]</span>
                    <span class="c1">#     s_pca = s_pca[self.sp_info.Cluster == cluster_label1]</span>
                    <span class="c1">#     </span>
                    <span class="c1">#     ax.scatter(x_pca[:,0], x_pca[:,1], </span>
                    <span class="c1">#                 marker=&quot;*&quot;, c=self.labels_[self.labels_ == cluster_label1])</span>
                    <span class="c1">#     ax.scatter(s_pca[:, 0], s_pca[:, 1], marker=&quot;p&quot;)</span>
                    <span class="c1">#     </span>
                    <span class="c1">#     ax.scatter(object1[0],  object1[1], marker=&quot;*&quot;, s=ind_marker_size)</span>
                    <span class="c1">#     ax.text(object1[0], object1[1], s=str(index1), color=ind_color)</span>
                    <span class="c1">#     </span>
                    <span class="c1">#     for i in range(s_pca.shape[0]):</span>
                    <span class="c1">#         ax.add_patch(plt.Circle((s_pca[i, 0], s_pca[i, 1]), self.radius, fill=False, color=color, alpha=alpha, lw=cline_width, clip_on=False))</span>
                    <span class="c1">#         ax.set_aspect(&#39;equal&#39;, adjustable=&#39;datalim&#39;)</span>
                    <span class="c1">#         plt.text(s_pca[i, 0], s_pca[i, 1],</span>
                    <span class="c1">#                  s=self.splist[self.sp_info.Cluster == cluster_label1,1][i].astype(int).astype(str), </span>
                    <span class="c1">#                  bbox=sp_bbox)</span>
                    <span class="c1">#     ax.plot() </span>
                    <span class="c1">#     if savefig:</span>
                    <span class="c1">#         if not os.path.exists(&quot;img&quot;):</span>
                    <span class="c1">#             os.mkdir(&quot;img&quot;)</span>
                    <span class="c1">#             plt.savefig(&#39;img/ind1.pdf&#39;)</span>
                    <span class="c1">#             print(&quot;successfully save&quot;)</span>
                    <span class="c1">#     plt.show()</span>
                
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sd">&quot;&quot;&quot;The data point %(index1)i is in group %(agg_id)i, which has been merged into cluster #%(m_c)i.&quot;&quot;&quot;</span><span class="o">%</span> <span class="p">{</span>
                        <span class="s2">&quot;index1&quot;</span><span class="p">:</span><span class="n">index1</span><span class="p">,</span> <span class="s2">&quot;agg_id&quot;</span><span class="p">:</span><span class="n">agg_label1</span><span class="p">,</span> <span class="s2">&quot;m_c&quot;</span><span class="p">:</span><span class="n">cluster_label1</span>
                    <span class="p">}</span>
                <span class="p">)</span>

                <span class="c1">#  print(&quot;then assigned to cluster %(m_c)i.&quot; % {</span>
                <span class="c1">#      &quot;m_c&quot;:cluster_label1</span>
                <span class="c1"># })</span>

                <span class="c1"># if showsplist:</span>
                <span class="c1">#     print(dash_line)</span>
                <span class="c1">#     spdisplay = self.sp_info.iloc[[agg_label1],:]</span>
                <span class="c1">#     spdisplay[&quot;Data points&quot;] = [str(index1)]</span>
                <span class="c1">#     spdisplay = spdisplay[[&quot;Data points&quot;, &quot;Group&quot;, &quot;NrPts&quot;, &quot;Cluster&quot;, &quot;Coordinates&quot;]] </span>
                <span class="c1">#     print(spdisplay.to_string(justify=&#39;center&#39;, index=False, max_colwidth=max_colwidth))</span>
                <span class="c1">#     print(dash_line)</span>
                

            <span class="c1"># explain two objects relationship</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># explain(index1, index2)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index2</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">object2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_pca</span><span class="p">[</span><span class="n">index2</span><span class="p">]</span> <span class="c1"># self.data has been normalized</span>
                    <span class="n">agg_label2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">agg_labels</span><span class="p">[</span><span class="n">index2</span><span class="p">]</span> <span class="c1"># get the group index for object2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">object2</span> <span class="o">=</span> <span class="p">(</span><span class="n">index2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mu</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span> <span class="c1"># allow for out-sample data</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">object2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">object2</span><span class="p">)</span>
                    <span class="n">agg_label2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_pca</span> <span class="o">-</span> <span class="n">object2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span> <span class="c1"># get the group index for object2</span>

                <span class="k">if</span> <span class="n">replace_name</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">replace_name</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">index1_name</span> <span class="o">=</span> <span class="n">replace_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">index2_name</span> <span class="o">=</span> <span class="n">replace_name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">index1_name</span> <span class="o">=</span> <span class="n">replace_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">index2_name</span> <span class="o">=</span> <span class="n">index2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">index1_name</span> <span class="o">=</span> <span class="n">index1</span>
                    <span class="n">index2_name</span> <span class="o">=</span> <span class="n">index2</span>

                <span class="n">cluster_label1</span><span class="p">,</span> <span class="n">cluster_label2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_change</span><span class="p">[</span><span class="n">agg_label1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_change</span><span class="p">[</span><span class="n">agg_label2</span><span class="p">]</span>

                <span class="n">connected_groups</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">subs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_groups</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">agg_label1</span> <span class="ow">in</span> <span class="n">subs</span> <span class="ow">and</span> <span class="n">agg_label2</span> <span class="ow">in</span> <span class="n">subs</span><span class="p">:</span>
                        <span class="n">connected_groups</span><span class="p">[</span><span class="s2">&quot;object 1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">connected_groups</span><span class="p">[</span><span class="s2">&quot;object 2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">subs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">agg_label1</span> <span class="ow">in</span> <span class="n">subs</span><span class="p">:</span>
                        <span class="n">connected_groups</span><span class="p">[</span><span class="s2">&quot;object 1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">subs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">agg_label2</span> <span class="ow">in</span> <span class="n">subs</span><span class="p">:</span>
                        <span class="n">connected_groups</span><span class="p">[</span><span class="s2">&quot;object 2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">subs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
               
                
                <span class="k">if</span> <span class="n">agg_label1</span> <span class="o">==</span> <span class="n">agg_label2</span><span class="p">:</span> <span class="c1"># when ind1 &amp; ind2 are in the same group</span>
                    <span class="n">sp_str</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="p">[</span><span class="n">agg_label1</span><span class="p">,</span> <span class="mi">3</span><span class="p">:],</span> <span class="n">separator</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The data points </span><span class="si">%(index1)s</span><span class="s2"> and </span><span class="si">%(index2)s</span><span class="s2"> are in the same group </span><span class="si">%(agg_id)i</span><span class="s2">, hence were merged into the same cluster #</span><span class="si">%(m_c)i</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">{</span>
                        <span class="s2">&quot;index1&quot;</span><span class="p">:</span><span class="n">index1</span><span class="p">,</span> <span class="s2">&quot;index2&quot;</span><span class="p">:</span><span class="n">index2</span><span class="p">,</span> <span class="s2">&quot;agg_id&quot;</span><span class="p">:</span><span class="n">agg_label1</span><span class="p">,</span> <span class="s2">&quot;m_c&quot;</span><span class="p">:</span><span class="n">cluster_label1</span><span class="p">}</span>
                    <span class="p">)</span>
                    <span class="n">connected_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">agg_label1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sp1_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="p">[</span><span class="n">agg_label1</span><span class="p">,</span> <span class="mi">3</span><span class="p">:]</span>
                    <span class="n">sp2_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="p">[</span><span class="n">agg_label2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:]</span>
                    <span class="c1"># print(&quot;&quot;&quot;The two objects are assigned to different groups through aggregation.&quot;&quot;&quot;)</span>

                    <span class="c1"># print(</span>
                    <span class="c1"># &quot;&quot;&quot;The first object is aggregated to group %(agg_id)i associated with starting point %(sp)s with respect to radius %(radius)s, then assigned to cluster label %(m_c)i.&quot;&quot;&quot; % {</span>
                    <span class="c1">#     &quot;agg_id&quot;:agg_label1, &quot;sp&quot;:sp1_str, &quot;radius&quot;:self.radius, &quot;m_c&quot;:cluster_label1</span>
                    <span class="c1"># })</span>

                    <span class="c1"># print(</span>
                    <span class="c1"># &quot;&quot;&quot;The second object is aggregated to group %(agg_id)i associated with starting point %(sp)s with respect to radius %(radius)s, then assigned to cluster label %(m_c)i.&quot;&quot;&quot; % {</span>
                    <span class="c1">#     &quot;agg_id&quot;:agg_label2, &quot;sp&quot;:sp2_str, &quot;radius&quot;:self.radius, &quot;m_c&quot;:cluster_label2</span>
                    <span class="c1"># })</span>
                    
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected_pairs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">distm</span> <span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="p">[:,</span><span class="mi">3</span><span class="p">:],</span> <span class="n">Y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
                        <span class="n">distm</span> <span class="o">=</span> <span class="p">(</span><span class="n">distm</span> <span class="o">&lt;=</span> <span class="n">radius</span><span class="o">*</span><span class="n">scale</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">connected_pairs</span> <span class="o">=</span> <span class="n">return_csr_matrix_indices</span><span class="p">(</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">distm</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="c1"># list</span>
                        
                    <span class="k">if</span> <span class="n">cluster_label1</span> <span class="o">==</span> <span class="n">cluster_label2</span><span class="p">:</span> <span class="c1"># when ind1 &amp; ind2 are in the same cluster but diff group</span>
                        <span class="c1"># deprecated (24/07/2021)  from scipy.sparse.csgraph import shortest_path -&gt; Dijkstraâs algorithm </span>
                        <span class="c1"># path_graph = pairs_to_graph(self.connected_pairs, N=self.splist.shape[0], sparse=True)</span>
                        <span class="c1">## apply Dijkstraâs algorithm with Fibonacci heaps for shortest path finding</span>
                        <span class="c1"># dist_matrix, predecessors = shortest_path(csgraph=path_graph, method=&quot;D&quot;, directed=False, return_predecessors=True) </span>
                        <span class="c1"># connected_paths = get_shortest_path(predecessors, agg_label1, agg_label2)</span>
                        <span class="n">connected_paths</span> <span class="o">=</span> <span class="n">find_shortest_path</span><span class="p">(</span><span class="n">agg_label1</span><span class="p">,</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">connected_pairs</span><span class="p">,</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                             <span class="n">agg_label2</span>
                        <span class="p">)</span>
                        
                        <span class="c1"># -- Deprecated</span>
                        <span class="c1"># if agg_label1 != 0:</span>
                        <span class="c1">#     connected_paths_vis = &quot; -&gt; &quot;.join([str(group) for group in connected_paths]) </span>
                        <span class="c1"># else:</span>
                        <span class="c1">#     connected_paths_vis = &quot; -&gt; &quot;.join([&quot;0&quot;] + [str(group) for group in connected_paths]) </span>
                        
                        <span class="n">connected_paths_vis</span> <span class="o">=</span> <span class="s2">&quot; &lt;-&gt; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">connected_paths</span><span class="p">])</span> 
                        <span class="nb">print</span><span class="p">(</span>
                        <span class="sd">&quot;&quot;&quot;The data point %(index1)s is in group %(agg_id1)s and the data point %(index2)s is in group %(agg_id2)s, &quot;&quot;&quot;</span>
                            <span class="sd">&quot;&quot;&quot;\nboth of which were merged into cluster #%(cluster)i. &quot;&quot;&quot;</span><span class="o">%</span> <span class="p">{</span>
                            <span class="s2">&quot;index1&quot;</span><span class="p">:</span><span class="n">index1</span><span class="p">,</span> <span class="s2">&quot;index2&quot;</span><span class="p">:</span><span class="n">index2</span><span class="p">,</span> <span class="s2">&quot;cluster&quot;</span><span class="p">:</span><span class="n">cluster_label1</span><span class="p">,</span> <span class="s2">&quot;agg_id1&quot;</span><span class="p">:</span><span class="n">agg_label1</span><span class="p">,</span> <span class="s2">&quot;agg_id2&quot;</span><span class="p">:</span><span class="n">agg_label2</span><span class="p">}</span>
                        <span class="p">)</span>
                        
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;These two groups are connected via groups </span><span class="si">%(connected)s</span><span class="s2">.&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span>
                               <span class="s2">&quot;connected&quot;</span><span class="p">:</span><span class="n">connected_paths_vis</span><span class="p">}</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span> 
                        <span class="c1"># alternative expression 1</span>
                        <span class="c1"># print(&quot;The two objects are allocated to two different cluster.&quot;)</span>
                        <span class="c1"># print(</span>
                        <span class="c1"># &quot;&quot;&quot;The first object is allocated to the cluster %(c_id1)s via %(connected1)s with cluster center %(cen1)s</span>
                        <span class="c1"># while the second object is allocated to the cluster %(c_id2)s via %(connected2)s with cluster center %(cen2)s&quot;&quot;&quot; % {</span>
                        <span class="c1"># &quot;c_id1&quot;:cluster_label1, &quot;connected1&quot;: connected_groups[&quot;object 1&quot;], &quot;cen1&quot;:cen1_str,</span>
                        <span class="c1"># &quot;c_id2&quot;:cluster_label2, &quot;connected2&quot;: connected_groups[&quot;object 2&quot;], &quot;cen1&quot;:cen2_str</span>
                        <span class="c1">#     }</span>
                        <span class="c1"># )</span>
                        <span class="c1"># print(&quot;The two objects are allocated to two different cluster.&quot;)</span>
                        
                        <span class="c1"># alternative expression 2</span>
                        <span class="c1"># print(&quot;&quot;&quot;The data point %(index1)s is in group %(agg_id1)i, which has been merged into cluster %(c_id1)s via connected groups %(connected1)s.&quot;&quot;&quot; % {</span>
                        <span class="c1">#     &quot;index1&quot;:index1, &quot;agg_id1&quot;:agg_label1, &quot;c_id1&quot;:cluster_label1, &quot;connected1&quot;: connected_groups[&quot;object 1&quot;]</span>
                        <span class="c1"># })</span>

                        <span class="c1"># print(&quot;&quot;&quot;\nThe data point %(index2)s is in group %(agg_id2)i, which has been merged into cluster %(c_id2)s via connected groups %(connected2)s.&quot;&quot;&quot; % {</span>
                        <span class="c1">#     &quot;index2&quot;:index2, &quot;agg_id2&quot;:agg_label2, &quot;c_id2&quot;:cluster_label2, &quot;connected2&quot;: connected_groups[&quot;object 2&quot;]</span>
                        <span class="c1"># })</span>
                        <span class="n">connected_paths</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;The data point </span><span class="si">%(index1)s</span><span class="s2"> is in group </span><span class="si">%(agg_id1)i</span><span class="s2">, which has been merged into cluster </span><span class="si">%(c_id1)s</span><span class="s2">.&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span>
                            <span class="s2">&quot;index1&quot;</span><span class="p">:</span><span class="n">index1</span><span class="p">,</span> <span class="s2">&quot;agg_id1&quot;</span><span class="p">:</span><span class="n">agg_label1</span><span class="p">,</span> <span class="s2">&quot;c_id1&quot;</span><span class="p">:</span><span class="n">cluster_label1</span><span class="p">})</span>

                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;The data point </span><span class="si">%(index2)s</span><span class="s2"> is in group </span><span class="si">%(agg_id2)i</span><span class="s2">, which has been merged into cluster </span><span class="si">%(c_id2)s</span><span class="s2">.&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span>
                            <span class="s2">&quot;index2&quot;</span><span class="p">:</span><span class="n">index2</span><span class="p">,</span> <span class="s2">&quot;agg_id2&quot;</span><span class="p">:</span><span class="n">agg_label2</span><span class="p">,</span> <span class="s2">&quot;c_id2&quot;</span><span class="p">:</span><span class="n">cluster_label2</span><span class="p">})</span>   
                        
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;There is no path of overlapping groups between these clusters.&quot;&quot;&quot;</span><span class="p">)</span>
                        
                <span class="k">if</span> <span class="n">plot</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="n">figstyle</span><span class="p">)</span>
                    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;axes.facecolor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;whitesmoke&#39;</span>
                    <span class="c1"># select indices</span>
                    <span class="n">union_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_info</span><span class="o">.</span><span class="n">Cluster</span> <span class="o">==</span> <span class="n">cluster_label1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_info</span><span class="o">.</span><span class="n">Cluster</span> <span class="o">==</span> <span class="n">cluster_label2</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">x_pca1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_pca</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_</span> <span class="o">==</span> <span class="n">cluster_label1</span><span class="p">]</span>
                    <span class="n">x_pca2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_pca</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_</span> <span class="o">==</span> <span class="n">cluster_label2</span><span class="p">]</span>
                    <span class="n">s_pca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_pca</span><span class="p">[</span><span class="n">union_ind</span><span class="p">]</span>
                    <span class="c1"># self.s_pca[]</span>
                    
                    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x_pca1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x_pca1</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_color</span><span class="p">[</span><span class="n">cluster_label1</span><span class="p">])</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x_pca2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x_pca2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_color</span><span class="p">[</span><span class="n">cluster_label2</span><span class="p">])</span>
                    
                    <span class="c1"># ax.scatter(x_pca1[:, 0], x_pca1[:, 1],</span>
                    <span class="c1">#             marker=&quot;*&quot;, c=&#39;lightgreen&#39;)</span>
                    <span class="c1"># ax.scatter(x_pca2[:, 0], x_pca2[:, 1],</span>
                    <span class="c1">#             marker=&quot;*&quot;, c=&#39;lightblue&#39;)</span>
                    
                    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">s_pca</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">s_pca</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
                    
                    <span class="k">if</span> <span class="n">dp_fontsize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">object1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">object1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">index1_name</span><span class="p">),</span> <span class="n">bbox</span><span class="o">=</span><span class="n">dp_bbox</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">ind_color</span><span class="p">)</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">object2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">object2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">index2_name</span><span class="p">),</span> <span class="n">bbox</span><span class="o">=</span><span class="n">dp_bbox</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">ind_color</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">object1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">object1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">index1_name</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">dp_fontsize</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">dp_bbox</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">ind_color</span><span class="p">)</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">object2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">object2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">index2_name</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">dp_fontsize</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">dp_bbox</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">ind_color</span><span class="p">)</span>
                    
                    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">object1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">object1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">ind_marker_size</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">object2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">object2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">ind_marker_size</span><span class="p">)</span>
                    
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s_pca</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="k">if</span> <span class="n">union_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">connected_paths</span><span class="p">:</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">((</span><span class="n">s_pca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">s_pca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">connect_color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="n">cline_width</span><span class="p">,</span> <span class="n">clip_on</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">((</span><span class="n">s_pca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">s_pca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="n">cline_width</span><span class="p">,</span> <span class="n">clip_on</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span> <span class="n">adjustable</span><span class="o">=</span><span class="s1">&#39;datalim&#39;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">sp_fontsize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">s_pca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">s_pca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> 
                                    <span class="n">s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_info</span><span class="o">.</span><span class="n">Group</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_info</span><span class="o">.</span><span class="n">Cluster</span> <span class="o">==</span> <span class="n">cluster_label1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_info</span><span class="o">.</span><span class="n">Cluster</span> <span class="o">==</span> <span class="n">cluster_label2</span><span class="p">)]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">),</span>
                                    <span class="n">bbox</span><span class="o">=</span><span class="n">sp_bbox</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">s_pca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">s_pca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> 
                                    <span class="n">s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_info</span><span class="o">.</span><span class="n">Group</span><span class="p">[</span><span class="n">union_ind</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">),</span>
                                    <span class="n">fontsize</span><span class="o">=</span><span class="n">sp_fontsize</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">sp_bbox</span>
                            <span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span> <span class="c1"># the axis here may not be consistent, so hide.</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">savefig</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s2">&quot;img&quot;</span><span class="p">):</span>
                            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="s2">&quot;img&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">&#39;pdf&#39;</span><span class="p">:</span>
                            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;img/&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">figname</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">index1</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">index2</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39;.pdf&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">&#39;png&#39;</span><span class="p">:</span>
                            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;img/&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">figname</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">index1</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">index2</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39;.png&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;img/&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">figname</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">index1</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">index2</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">fmt</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;image successfully save.&quot;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
                    
                    <span class="c1"># deprecated (24/07/2021):</span>
                    <span class="c1"># if self.data.shape[1] &gt; 2:</span>
                    <span class="c1">#     pca = PCA(n_components=2)</span>
                    <span class="c1">#     x_pca = pca.fit_transform(self.data)</span>
                    <span class="c1">#     s_pca = pca.transform(self.splist[:, 3:])</span>
                    <span class="c1">#     </span>
                    <span class="c1">#     # select indices</span>
                    <span class="c1">#     x_pca = x_pca[(self.labels_ == cluster_label1) | (self.labels_ == cluster_label2)]</span>
                    <span class="c1">#     s_pca = s_pca[(self.sp_info.Cluster == cluster_label1) | (self.sp_info.Cluster == cluster_label2)]</span>
                    <span class="c1">#     </span>
                    <span class="c1">#     ax.scatter(x_pca[:, 0], x_pca[:, 1],</span>
                    <span class="c1">#                 marker=&quot;*&quot;, c=self.labels_[(self.labels_ == cluster_label1) | (self.labels_ == cluster_label2)])</span>
                    <span class="c1">#     ax.scatter(s_pca[:,0], s_pca[:,1], marker=&quot;p&quot;)</span>
                    <span class="c1">#     </span>
                    <span class="c1">#     ax.scatter(object1[0],  object1[1], marker=&quot;*&quot;, s=ind_marker_size)</span>
                    <span class="c1">#     ax.text(object1[0], object1[1], s=str(index1), color=ind_color)</span>
                    <span class="c1">#     </span>
                    <span class="c1">#     ax.scatter(object2[0],  object2[1], marker=&quot;*&quot;, s=ind_marker_size)</span>
                    <span class="c1">#     ax.text(object2[0], object2[1], s=str(index2), color=ind_color)</span>
                    <span class="c1">#         </span>
                    <span class="c1">#     for i in range(s_pca.shape[0]):</span>
                    <span class="c1">#         ax.add_patch(plt.Circle((s_pca[i, 0], s_pca[i, 1]), self.radius, fill=False, color=color, alpha=alpha, lw=cline_width, clip_on=False))</span>
                    <span class="c1">#         ax.set_aspect(&#39;equal&#39;, adjustable=&#39;datalim&#39;)</span>
                    <span class="c1">#         ax.text(s_pca[i, 0], s_pca[i, 1], </span>
                    <span class="c1">#             s=self.sp_info.Group[(self.sp_info.Cluster == cluster_label1) | (self.sp_info.Cluster == cluster_label2)].values[i].astype(int).astype(str),</span>
                    <span class="c1">#             bbox=sp_bbox)</span>
                    <span class="c1">#     </span>
                    <span class="c1">#     ax.plot()</span>
                    <span class="c1">#     if savefig:</span>
                    <span class="c1">#         if not os.path.exists(&quot;img&quot;):</span>
                    <span class="c1">#             os.mkdir(&quot;img&quot;)</span>
                    <span class="c1">#             plt.savefig(&#39;img/ind1_ind2.pdf&#39;)</span>
                    <span class="c1">#             print(&quot;successfully save&quot;)</span>
                    <span class="c1">#     plt.show()</span>
                    <span class="c1">#     </span>
                    <span class="c1"># elif self.data.shape[1] == 2:</span>
                    <span class="c1">#     x_pca = self.data.copy()</span>
                    <span class="c1">#     s_pca = self.splist[:, 3:].copy()</span>
                    <span class="c1">#     </span>
                    <span class="c1">#     # select indices</span>
                    <span class="c1">#     x_pca = x_pca[(self.labels_ == cluster_label1) | (self.labels_ == cluster_label2)]</span>
                    <span class="c1">#     s_pca = s_pca[(self.sp_info.Cluster == cluster_label1) | (self.sp_info.Cluster == cluster_label2)]</span>
                    <span class="c1">#     </span>
                    <span class="c1">#     ax.scatter(x_pca[:,0], x_pca[:,1], </span>
                    <span class="c1">#                 marker=&quot;*&quot;, c=self.labels_[(self.labels_ == cluster_label1) | (self.labels_ == cluster_label2)])</span>
                    <span class="c1">#     ax.scatter(s_pca[:, 0], s_pca[:, 1], marker=&quot;p&quot;)</span>
                    <span class="c1">#     </span>
                    <span class="c1">#     ax.scatter(object1[0],  object1[1], marker=&quot;*&quot;, s=ind_marker_size)</span>
                    <span class="c1">#     ax.text(object1[0], object1[1], str(index1), color=ind_color)</span>
                    <span class="c1">#     </span>
                    <span class="c1">#     ax.scatter(object2[0],  object2[1], marker=&quot;*&quot;, s=ind_marker_size)</span>
                    <span class="c1">#     ax.text(object2[0], object2[1], str(index2), color=ind_color)</span>
                    <span class="c1">#     </span>
                    <span class="c1">#     for i in range(s_pca.shape[0]):</span>
                    <span class="c1">#         ax.add_patch(plt.Circle((s_pca[i, 0], s_pca[i, 1]), self.radius, fill=False, color=color, alpha=alpha, lw=cline_width, clip_on=False))</span>
                    <span class="c1">#         ax.set_aspect(&#39;equal&#39;, adjustable=&#39;datalim&#39;)</span>
                    <span class="c1">#         ax.text(s_pca[i, 0], s_pca[i, 1],</span>
                    <span class="c1">#             s=self.sp_info.Group[(self.sp_info.Cluster == cluster_label1) | (self.sp_info.Cluster == cluster_label2)].values[i].astype(int).astype(str), </span>
                    <span class="c1">#             bbox=sp_bbox)</span>
                    <span class="c1">#     </span>
                    <span class="c1">#     ax.plot()</span>
                    <span class="c1">#     if savefig:</span>
                    <span class="c1">#         if not os.path.exists(&quot;img&quot;):</span>
                    <span class="c1">#             os.mkdir(&quot;img&quot;)</span>
                    <span class="c1">#             plt.savefig(&#39;img/ind1_ind2.pdf&#39;)</span>
                    <span class="c1">#             print(&quot;successfully save&quot;)</span>
                    <span class="c1">#     plt.show()</span>
                    <span class="c1">#     </span>
                    <span class="c1"># else:</span>
                    <span class="c1">#     print(&quot;This function is restricted to multidimensional (dimension greater than or equal to 2) data.&quot;)</span>
                        

                        
                <span class="c1"># if showsplist:</span>
                <span class="c1">#     print(dash_line)</span>
                <span class="c1">#     spdisplay = self.sp_info.iloc[[agg_label1, agg_label2],:]</span>
                <span class="c1">#     spdisplay[&quot;Data points&quot;] = [str(index1), str(index2)]</span>
                <span class="c1">#     spdisplay = spdisplay[[&quot;Data points&quot;, &quot;Group&quot;, &quot;NrPts&quot;, &quot;Cluster&quot;, &quot;Coordinates&quot;]] </span>
                <span class="c1">#     print(spdisplay.to_string(justify=&#39;center&#39;, index=False, max_colwidth=max_colwidth))</span>
                <span class="c1">#     print(dash_line)</span>
                
        <span class="k">return</span> </div>
    
    
    
<div class="viewcode-block" id="CLASSIX.explain_viz"><a class="viewcode-back" href="../../clustering_parameters.html#classix.clustering.CLASSIX.explain_viz">[docs]</a>    <span class="k">def</span> <span class="nf">explain_viz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">figstyle</span><span class="o">=</span><span class="s2">&quot;ggplot&quot;</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;facecolor&#39;</span><span class="p">:</span> <span class="s1">&#39;tomato&#39;</span><span class="p">,</span> <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="mf">0.3</span><span class="p">,</span> <span class="s1">&#39;pad&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;off&#39;</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;pdf&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Visualize the starting point and data points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cluster_color</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cluster_color</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;#</span><span class="si">%06X</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0xFFFFFF</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;default&#39;</span><span class="p">)</span> <span class="c1"># clear the privous figure style</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="n">figstyle</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;axes.facecolor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;whitesmoke&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_pca</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_pca</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_</span><span class="p">):</span>
                <span class="n">x_pca_part</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_pca</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_</span> <span class="o">==</span> <span class="n">i</span><span class="p">,:]</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x_pca_part</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_pca_part</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_color</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="c1"># plt.scatter(x_pca_part[:,0], x_pca_part[:,1], marker=&quot;*&quot;, c=&#39;#%06X&#39; % np.random.randint(0, 0xFFFFFF))</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_pca</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">fontsize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_pca</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_pca</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="n">bbox</span><span class="o">=</span><span class="n">bbox</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_pca</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_pca</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">bbox</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="c1"># the axis here may not be consistent, so hide.</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_pca</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_pca</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="mf">0.1</span><span class="p">])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_pca</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_pca</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mf">0.1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Visualization is restricted to multidimensional (dimension greater than or equal to 2) data.&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">savefig</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s2">&quot;img&quot;</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="s2">&quot;img&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">&#39;pdf&#39;</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;img/explain_viz.pdf&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">&#39;png&#39;</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;img/explain_viz.png&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;img/explain_viz.&#39;</span><span class="o">+</span><span class="n">fmt</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;successfully save&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        
        <span class="k">return</span></div>
        
        

<div class="viewcode-block" id="CLASSIX.form_starting_point_clusters_table"><a class="viewcode-back" href="../../clustering_parameters.html#classix.clustering.CLASSIX.form_starting_point_clusters_table">[docs]</a>    <span class="k">def</span> <span class="nf">form_starting_point_clusters_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aggregate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;form the columns details for starting points and clusters information&quot;&quot;&quot;</span>
        <span class="c1"># won&#39;t change the original order of self.splist</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Group&quot;</span><span class="p">,</span> <span class="s2">&quot;NrPts&quot;</span><span class="p">]</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">aggregate</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:],</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">():</span>
                <span class="n">fill</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">:</span>
                        <span class="n">fill</span> <span class="o">=</span> <span class="n">fill</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">[:</span><span class="mi">5</span><span class="p">]:</span>
                        <span class="n">fill</span> <span class="o">=</span> <span class="n">fill</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span>
                    <span class="n">fill</span> <span class="o">=</span> <span class="n">fill</span> <span class="o">+</span> <span class="s2">&quot;...&quot;</span>
                <span class="n">fill</span> <span class="o">+=</span> <span class="s2">&quot;&quot;</span>
                <span class="n">coord</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fill</span><span class="p">)</span>

            <span class="c1"># self.sp_info = pd.DataFrame(self.splist[:, 1:2], columns=cols)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]:</span>
                <span class="n">fill</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="n">sp_item</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="p">:],</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sp_item</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">sp_item</span><span class="p">:</span>
                        <span class="n">fill</span> <span class="o">=</span> <span class="n">fill</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">sp_item</span><span class="p">[:</span><span class="mi">5</span><span class="p">]:</span>
                        <span class="n">fill</span> <span class="o">=</span> <span class="n">fill</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span>
                    <span class="n">fill</span> <span class="o">=</span> <span class="n">fill</span> <span class="o">+</span> <span class="s2">&quot;...&quot;</span>
                <span class="n">fill</span> <span class="o">+=</span> <span class="s2">&quot;&quot;</span>
                <span class="n">coord</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fill</span><span class="p">)</span>
                
        <span class="bp">self</span><span class="o">.</span><span class="n">sp_info</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sp_info</span><span class="p">[</span><span class="s2">&quot;Group&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sp_info</span><span class="p">[</span><span class="s2">&quot;NrPts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sp_info</span><span class="p">[</span><span class="s2">&quot;Cluster&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">label_change</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sp_info</span><span class="p">[</span><span class="s2">&quot;Coordinates&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span> <span class="c1"># np.around(self.splist[:,3:], 2).tolist()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sp_to_c_info</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span></div>
        
        
    
    <span class="k">def</span> <span class="nf">visualize_linkage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">),</span> <span class="n">labelsize</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">320</span><span class="p">,</span> <span class="n">plot_boundary</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                             <span class="n">bound_color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;pdf&#39;</span><span class="p">):</span>
        
        <span class="n">distm</span><span class="p">,</span> <span class="n">n_components</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">visualize_connections</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="nb">round</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="c1"># plt.figure(figsize=figsize)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;axes.facecolor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;white&#39;</span>
        <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_scl</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mu</span>
        <span class="n">link_list</span> <span class="o">=</span> <span class="n">return_csr_matrix_indices</span><span class="p">(</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">distm</span><span class="p">))</span>
        
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">markersize</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">plot_boundary</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">((</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span> 
                                        <span class="n">color</span><span class="o">=</span><span class="n">bound_color</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">clip_on</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                            <span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span> <span class="n">adjustable</span><span class="o">=</span><span class="s1">&#39;datalim&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">link_list</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">edge</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span> 
        
        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="n">labelsize</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">&#39;pdf&#39;</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="s1">&#39;/linkage_scale_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39;_tol_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39;.pdf&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="s1">&#39;/linkage_scale_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39;_tol_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39;.png&#39;</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
        <span class="c1"># plt.show()</span>
    
    
    
    <span class="k">def</span> <span class="nf">load_splist_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">splist_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">splist_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">splist_indices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">splist</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">splist_indices</span>
        
        
        
    <span class="k">def</span> <span class="nf">load_cluster_centers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">centers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">centers</span> <span class="o">=</span> <span class="n">calculate_cluster_centers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_scl</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">centers</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">centers</span>
        
        
    <span class="k">def</span> <span class="nf">calculate_group_centers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span> 
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
            <span class="n">indc</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">c</span><span class="p">]</span>
            <span class="n">indc</span> <span class="o">=</span> <span class="p">(</span><span class="n">labels</span><span class="o">==</span><span class="n">c</span><span class="p">)</span>
            <span class="n">center</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">indc</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">center</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">centers</span>

    
    
<div class="viewcode-block" id="CLASSIX.outlier_filter"><a class="viewcode-back" href="../../clustering_parameters.html#classix.clustering.CLASSIX.outlier_filter">[docs]</a>    <span class="k">def</span> <span class="nf">outlier_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_samples_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span> <span class="c1"># percent</span>
        <span class="sd">&quot;&quot;&quot;Filter outliers in terms of min_samples&quot;&quot;&quot;</span>
        <span class="c1"># print(&quot;Min_samples (minPts):{:.0f}&quot;.format(min_samples))</span>
        <span class="c1"># self.cluster_count_dict = collections.Counter(labels) # move</span>
        <span class="k">if</span> <span class="n">min_samples</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">min_samples</span> <span class="o">=</span> <span class="n">min_samples_rate</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">old_cluster_count</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            
        <span class="c1"># threshold = np.percentile(</span>
        <span class="c1">#    a=np.array(list(count_dict.values())), q=percent,</span>
        <span class="c1">#    interpolation=&#39;linear&#39;, axis=-1)</span>
        
        <span class="c1"># return [i[0] for i in count_dict.items() </span>
        <span class="c1">#         if i[1] &lt;= threshold and i[1] &lt;= min_samples]</span>
        
        <span class="c1"># filter minimum number of points each cluster smaller than scale</span>
        
        <span class="k">return</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">old_cluster_count</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_samples</span><span class="p">]</span></div>
    
    
    <span class="c1"># deprecated (24/07/2021)</span>
    <span class="c1"># def merge_pairs(self, pairs):</span>
    <span class="c1">#     &quot;&quot;&quot;Transform connected pairs to connected groups (list)&quot;&quot;&quot;</span>
    <span class="c1">#     </span>
    <span class="c1">#     ulabels = np.full(len_p, -1, dtype=int)</span>
    <span class="c1">#     labels = list()</span>
    <span class="c1">#     maxid = 0</span>
    <span class="c1">#     for i in range(len(pairs)):</span>
    <span class="c1">#         if ulabels[i] == -1:</span>
    <span class="c1">#             sub = pairs[i]</span>
    <span class="c1">#             ulabels[i] = maxid</span>
    <span class="c1"># </span>
    <span class="c1">#             for j in range(i+1, len(pairs)):</span>
    <span class="c1">#                 com = pairs[j]</span>
    <span class="c1">#                 if check_if_intersect(sub, com):</span>
    <span class="c1">#                     sub = sub + com</span>
    <span class="c1">#                     if ulabels[j] == -1:</span>
    <span class="c1">#                         ulabels[j] = maxid</span>
    <span class="c1">#                     else:</span>
    <span class="c1">#                         ulabels[ulabels == maxid] = ulabels[j]</span>
    <span class="c1"># </span>
    <span class="c1">#             maxid = maxid + 1</span>
    <span class="c1"># </span>
    <span class="c1">#     for i in np.unique(ulabels):</span>
    <span class="c1">#         sub = list()</span>
    <span class="c1">#         for j in np.where(ulabels == i)[0]:</span>
    <span class="c1">#             sub = sub + pairs[int(j)]</span>
    <span class="c1">#         labels.append(list(set(sub)))</span>
    <span class="c1">#     return labels</span>
    
    

    <span class="c1"># &quot;&quot;&quot;</span>
    <span class="c1"># def normalize(self, data, shift = &#39;z-score&#39;):</span>
    <span class="c1">#     if shift not in [&#39;mean&#39;, &#39;min&#39;, &#39;z-score&#39;]:</span>
    <span class="c1">#         raise ValueError(&quot;please enter a correct shift.&quot;)</span>
    <span class="c1">#         </span>
    <span class="c1">#     if shift == &#39;min&#39;:</span>
    <span class="c1">#         _mu = data.min(axis=0)</span>
    <span class="c1">#         _std = data.std()</span>
    <span class="c1">#         </span>
    <span class="c1">#     elif shift == &#39;mean&#39;:</span>
    <span class="c1">#         _mu = data.mean(axis=0)</span>
    <span class="c1">#         _std = data.std()</span>
    <span class="c1">#     </span>
    <span class="c1">#     else: #  shift == &#39;z-score&#39;:</span>
    <span class="c1">#         _mu = data.mean(axis=0)</span>
    <span class="c1">#         _std = data.std(axis=0)</span>
    <span class="c1">#         </span>
    <span class="c1">#     data = (data - _mu)/_std</span>
    <span class="c1">#     return data, (_mu, _std)    </span>
    <span class="c1"># &quot;&quot;&quot;</span>


        
    <span class="c1"># def check_if_intersect(self, l1, l2):</span>
    <span class="c1">#     return set(l1).intersection(l2) != set()</span>
  


    <span class="k">def</span> <span class="nf">reassign_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="c1"># unique_labels = sorted(np.unique(labels))</span>
        <span class="n">sorted_dict</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">old_cluster_count</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">clabels</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sorted_dict</span><span class="p">)):</span>
            <span class="n">clabels</span><span class="p">[</span><span class="n">labels</span> <span class="o">==</span> <span class="n">sorted_dict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>  <span class="o">=</span> <span class="n">i</span>
        <span class="k">return</span> <span class="n">clabels</span>

    

    <span class="k">def</span> <span class="nf">pprint_format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="p">):</span>
        <span class="c1"># lite-function to print dict or turple/list</span>
        <span class="n">cluster</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">items</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span> 
                <span class="c1"># print(&quot;      [-] cluster {} : {}&quot;.format(key, value))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;      * cluster </span><span class="si">{}</span><span class="s2"> : </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
                <span class="n">cluster</span> <span class="o">=</span> <span class="n">cluster</span> <span class="o">+</span> <span class="mi">1</span>
                
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;      * &quot;</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
            
        <span class="k">return</span> 
            

            
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_name</span> <span class="o">=</span> <span class="s2">&quot;CLASSIX(sorting=</span><span class="si">{0.sorting!r}</span><span class="s2">, radius=</span><span class="si">{0.radius!r}</span><span class="s2">, minPts=</span><span class="si">{0.minPts!r}</span><span class="s2">, group_merging=</span><span class="si">{0.group_merging!r}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_name</span> 

    
    
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_name</span> <span class="o">=</span> <span class="s1">&#39;CLASSIX(sorting=</span><span class="si">{0.sorting!r}</span><span class="s1">, radius=</span><span class="si">{0.radius!r}</span><span class="s1">, minPts=</span><span class="si">{0.minPts!r}</span><span class="s1">, group_merging=</span><span class="si">{0.group_merging!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_name</span>
    
    
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">radius</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radius</span>
    
    
    
    <span class="nd">@radius</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">radius</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected a float or int type&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Please feed an correct value (&gt;0) for tolerance&quot;</span><span class="p">)</span>
        <span class="c1"># if value &gt; 1:</span>
        <span class="c1">#     warnings.warn(&quot;Might lead to bad aggregation&quot;, DeprecationWarning)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_radius</span> <span class="o">=</span> <span class="n">value</span>
    
    
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sorting</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sorting</span>
    
    
    
    <span class="nd">@sorting</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">sorting</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected a string type&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;pca&#39;</span><span class="p">,</span> <span class="s1">&#39;norm-mean&#39;</span><span class="p">,</span> <span class="s1">&#39;norm-orthant&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">value</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Please refer to an correct sorting way, namely &#39;pca&#39;, &#39;norm-mean&#39; and &#39;norm-orthant&#39;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sorting</span> <span class="o">=</span> <span class="n">value</span>

        
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">group_merging</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_merging</span>
    
    
    
    <span class="nd">@group_merging</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">group_merging</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected a string type&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;density&#39;</span><span class="p">,</span> <span class="s1">&#39;distance&#39;</span><span class="p">]:</span> <span class="c1"># &#39;mst-distance&#39;, &#39;scc-distance&#39;, &#39;trivial-distance&#39;, &#39;trivial-density&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Please refer to an correct sorting way, namely &#39;density&#39; and &#39;distance&#39;&quot;</span>
                <span class="p">)</span> <span class="c1"># &#39;scc-distance&#39; and &#39;mst-distance&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group_merging</span> <span class="o">=</span> <span class="n">value</span>
        


    <span class="c1"># @property</span>
    <span class="c1"># def distance_scale(self):</span>
    <span class="c1">#     return self._distance_scale</span>
    
    
    
    <span class="c1"># @distance_scale.setter</span>
    <span class="c1"># def distance_scale(self, value):</span>
    <span class="c1">#     if not isinstance(value, float) and not isinstance(value, int):</span>
    <span class="c1">#         raise TypeError(&#39;Expected a float or int type&#39;)</span>
    <span class="c1">#     if value &lt;= 0:</span>
    <span class="c1">#         raise ValueError(</span>
    <span class="c1">#             &quot;Please feed an correct value for distance_scale&quot;)</span>

    <span class="c1">#     self._distance_scale = value</span>
    
        
    <span class="c1"># @property</span>
    <span class="c1"># def eta(self):</span>
    <span class="c1">#     return self._eta</span>
    
    
    
    <span class="c1"># @eta.setter</span>
    <span class="c1"># def eta(self, value):</span>
    <span class="c1">#     if not isinstance(value, float) and not isinstance(value, int):</span>
    <span class="c1">#         raise TypeError(&#39;Expected a float or int type&#39;)</span>
    <span class="c1">#     if value &lt;= 0:</span>
    <span class="c1">#         raise ValueError(</span>
    <span class="c1">#             &quot;Please feed an correct value for eta&quot;)</span>
    <span class="c1">#     self._eta = value</span>


        
    <span class="c1"># @property</span>
    <span class="c1"># def noise_percent(self):</span>
    <span class="c1">#     return self._noise_percent</span>
    
    
    
    <span class="c1"># @noise_percent.setter</span>
    <span class="c1"># def noise_percent(self, value):</span>
    <span class="c1">#     if not isinstance(value, float) and not isinstance(value,int):</span>
    <span class="c1">#         raise TypeError(&#39;Expected a float or int type&#39;)</span>
    <span class="c1">#     if value &lt; 0 or value &gt;= 100:</span>
    <span class="c1">#         raise ValueError(&#39;Percentiles must be in the range [0, 100)&#39;)</span>
    <span class="c1">#     self._noise_percent = value</span>
    
    
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">minPts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minPts</span>
    
    
    
    <span class="nd">@minPts</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">minPts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected a float or int type&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">value</span> <span class="o">&amp;</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Noise_scale must be 0 or greater than 1&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_minPts</span> <span class="o">=</span> <span class="n">value</span></div>
    
    

<span class="c1"># deprecated (24/07/2021)</span>
<span class="c1"># python implementation for aggregation</span>
<span class="c1"># def aggregate(data, sorting=&quot;pca&quot;, tol=0.5, verbose=1):</span>
<span class="c1">#     &quot;&quot;&quot;aggregate the data</span>
<span class="c1"># </span>
<span class="c1">#     Parameters</span>
<span class="c1">#     ----------</span>
<span class="c1">#     data : numpy.ndarray</span>
<span class="c1">#         the input that is array-like of shape (n_samples,).</span>
<span class="c1"># </span>
<span class="c1">#     sorting : str</span>
<span class="c1">#         the sorting way refered for aggregation, default=&#39;pca&#39;, other options: &#39;norm-mean&#39;, &#39;norm-orthant&#39;.</span>
<span class="c1"># </span>
<span class="c1">#     tol : float</span>
<span class="c1">#         the tolerance to control the aggregation, if the distance between the starting point </span>
<span class="c1">#         and the object is less than or equal than the tolerance,</span>
<span class="c1">#         the object should allocated to the group which starting point belongs to.  </span>
<span class="c1"># </span>
<span class="c1">#     Returns</span>
<span class="c1">#     -------</span>
<span class="c1">#     labels (list) : the group category of the data after aggregation</span>
<span class="c1">#     splist (list) : the list of the starting points</span>
<span class="c1">#     agg_centers (list) : store the centers of aggregation groups</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1"># </span>
<span class="c1">#     # nr_dist = 0 # if necessary, count the distance computation</span>
<span class="c1">#     splist = list() # store the starting points</span>
<span class="c1">#     len_ind = data.shape[0]</span>
<span class="c1"># </span>
<span class="c1">#     if sorting == &quot;norm-mean&quot;:</span>
<span class="c1">#         sort_vals = np.linalg.norm(data, ord=2, axis=1)</span>
<span class="c1">#         ind = np.argsort(sort_vals)</span>
<span class="c1"># </span>
<span class="c1">#     elif sorting == &quot;norm-orthant&quot;:</span>
<span class="c1">#         sort_vals = np.linalg.norm(data, ord=2, axis=1)</span>
<span class="c1">#         ind = np.argsort(sort_vals)</span>
<span class="c1"># </span>
<span class="c1">#     elif sorting == &quot;pca&quot;:</span>
<span class="c1">#         pca = PCA(n_components=1)</span>
<span class="c1">#         sort_vals = pca.fit_transform(data).reshape(-1)</span>
<span class="c1">#         ind = np.argsort(sort_vals)</span>
<span class="c1"># </span>
<span class="c1">#     else: # no sorting</span>
<span class="c1">#         ind = np.arange(len_ind)</span>
<span class="c1"># </span>
<span class="c1">#     lab = 0</span>
<span class="c1">#     labels = [-1] * len_ind</span>
<span class="c1"># </span>
<span class="c1">#     for i in tqdm(range(len_ind), disable=not verbose):</span>
<span class="c1">#         sp = ind[i] # starting point</span>
<span class="c1">#         if labels[sp] &gt;= 0:</span>
<span class="c1">#             continue</span>
<span class="c1">#         else:</span>
<span class="c1">#             clustc = data[sp,:] </span>
<span class="c1">#             labels[sp] = lab</span>
<span class="c1">#             num_group = 0</span>
<span class="c1"># </span>
<span class="c1">#         for j in ind[i:]:</span>
<span class="c1">#             if labels[j] &gt;= 0:</span>
<span class="c1">#                 continue</span>
<span class="c1"># </span>
<span class="c1">#             # sort_val_c = sort_vals[sp]</span>
<span class="c1">#             # sort_val_j = sort_vals[j]</span>
<span class="c1"># </span>
<span class="c1">#             if (sort_vals[j] - sort_vals[sp] &gt; tol):</span>
<span class="c1">#                 break       </span>
<span class="c1"># </span>
<span class="c1">#             # nr_dist += 1</span>
<span class="c1">#             # dist = np.sum((clustc - data[j,:])**2)    # slow</span>
<span class="c1"># </span>
<span class="c1">#             dat = clustc - data[j,:]</span>
<span class="c1">#             dist = np.inner(dat, dat)</span>
<span class="c1"># </span>
<span class="c1">#             if dist &lt;= tol**2:</span>
<span class="c1">#                 num_group = num_group + 1</span>
<span class="c1">#                 labels[j] = lab</span>
<span class="c1"># </span>
<span class="c1">#         splist.append([sp, lab] + [num_group] + list(clustc) ) # respectively store starting point</span>
<span class="c1">#                                                                # index, label, number of neighbor objects, center (starting point).</span>
<span class="c1">#         lab = lab + 1</span>
<span class="c1"># </span>
<span class="c1">#     agg_centers = list() </span>
<span class="c1">#     for c in range(lab):</span>
<span class="c1">#         indc = [i for i in range(len_ind) if labels[i] == c]</span>
<span class="c1">#         center = np.mean(data[indc,:], axis=0)</span>
<span class="c1">#         center = [-1, c] + center.tolist()</span>
<span class="c1">#         agg_centers.append( center )</span>
<span class="c1"># </span>
<span class="c1">#     # if verbose == 1:</span>
<span class="c1">#     #    print(&quot;aggregate {} groups&quot;.format(len(np.unique(labels))))</span>
<span class="c1"># </span>
<span class="c1">#     return labels, splist, agg_centers</span>



<span class="k">def</span> <span class="nf">pairwise_distance</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="n">distm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">distm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">distm</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">-</span><span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">,:],</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">distm</span>



<span class="k">def</span> <span class="nf">visualize_connections</span><span class="p">(</span><span class="n">splist</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.5</span><span class="p">):</span>
    <span class="n">distm</span> <span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">splist</span><span class="p">[:,</span><span class="mi">3</span><span class="p">:])</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="n">radius</span><span class="o">*</span><span class="n">scale</span>
    <span class="n">distm</span> <span class="o">=</span> <span class="p">(</span><span class="n">distm</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">n_components</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">connected_components</span><span class="p">(</span><span class="n">csgraph</span><span class="o">=</span><span class="n">distm</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">distm</span><span class="p">,</span> <span class="n">n_components</span><span class="p">,</span> <span class="n">labels</span>
    
    
    
<span class="k">def</span> <span class="nf">novel_normalization</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">base</span> <span class="o">==</span> <span class="s2">&quot;norm-mean&quot;</span><span class="p">:</span>
        <span class="c1"># self._mu, self._std = data.mean(axis=0), data.std()</span>
        <span class="n">_mu</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ndata</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mu</span>
        <span class="n">_scl</span> <span class="o">=</span> <span class="n">ndata</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
        <span class="n">ndata</span> <span class="o">=</span> <span class="n">ndata</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scl</span>

    <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s2">&quot;pca&quot;</span><span class="p">:</span>
        <span class="n">_mu</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ndata</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="n">_mu</span> <span class="c1"># mean center</span>
        <span class="n">rds</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">ndata</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># distance of each data point from 0</span>
        <span class="n">_scl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">rds</span><span class="p">)</span> <span class="c1"># 50% of data points are within that radius</span>
        <span class="n">ndata</span> <span class="o">=</span> <span class="n">ndata</span> <span class="o">/</span> <span class="n">_scl</span> <span class="c1"># now 50% of data are in unit ball </span>

    <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s2">&quot;norm-orthant&quot;</span><span class="p">:</span>
        <span class="c1"># self._mu, self._std = data.min(axis=0), data.std()</span>
        <span class="n">_mu</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ndata</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="n">_mu</span>
        <span class="n">_scl</span> <span class="o">=</span> <span class="n">ndata</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
        <span class="n">ndata</span> <span class="o">=</span> <span class="n">ndata</span> <span class="o">/</span> <span class="n">_scl</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># self._mu, self._std = data.mean(axis=0), data.std(axis=0) # z-score</span>
        <span class="n">_mu</span><span class="p">,</span> <span class="n">_scl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="c1"># no normalization</span>
        <span class="n">ndata</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">_mu</span><span class="p">)</span> <span class="o">/</span> <span class="n">_scl</span>
    <span class="k">return</span> <span class="n">ndata</span><span class="p">,</span> <span class="p">(</span><span class="n">_mu</span><span class="p">,</span> <span class="n">_scl</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">calculate_cluster_centers</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
    <span class="n">ulabels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
    <span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ulabels</span><span class="p">),</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ulabels</span><span class="p">:</span>
        <span class="n">indc</span> <span class="o">=</span> <span class="p">(</span><span class="n">labels</span><span class="o">==</span><span class="n">c</span><span class="p">)</span>
        <span class="n">centers</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">indc</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">centers</span>




<span class="c1"># ##########################################################################################################</span>
<span class="c1"># *************************** &lt;!-- the independent functions of checking overlap ***************************</span>
<span class="c1"># *******************************  determine if two groups should be merged ********************************</span>






<span class="k">def</span> <span class="nf">find_shortest_path</span><span class="p">(</span><span class="n">source_node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">connected_pairs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_node</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;get single-sourse shortest paths as well as distance from source node,</span>
<span class="sd">    design especially for unweighted undirected graph. The time complexity is O(|V| + |E|)</span>
<span class="sd">    where |V| is the number of vertices and |E| is the number of edges.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    source_node: int</span>
<span class="sd">        A given source vertex.</span>
<span class="sd">    </span>
<span class="sd">    connected_pairs: list</span>
<span class="sd">        The list stores connected nodes pairs.</span>
<span class="sd">    </span>
<span class="sd">    num_nodes: int</span>
<span class="sd">        The number of nodes existed in the graph.</span>
<span class="sd">        </span>
<span class="sd">    target_node: int, default=None</span>
<span class="sd">        Find the shortest paths from source node to target node.</span>
<span class="sd">        If not None, function returns the shortest path between source node and target node,</span>
<span class="sd">        otherwise returns table storing shortest path information.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dist_info: numpy.ndarray</span>
<span class="sd">        The table storing shortest path information.</span>
<span class="sd">    </span>
<span class="sd">    shortest_path_to_target: list</span>
<span class="sd">        The shortest path between source node and target node</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">visited_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span><span class="o">*</span><span class="n">num_nodes</span>
    <span class="n">queque</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">pairs_to_graph</span><span class="p">(</span><span class="n">connected_pairs</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">)</span> <span class="c1"># return sparse matrix</span>
    <span class="n">dist_info</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_nodes</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="c1"># node, dist, last node</span>
    <span class="n">dist_info</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
    <span class="n">dist_info</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_nodes</span> <span class="c1"># np.iinfo(np.int64).max</span>
    <span class="n">dist_info</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">source_node</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">source_node</span><span class="p">)</span>
    <span class="n">queque</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source_node</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dist_info</span><span class="p">[</span><span class="n">source_node</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">queque</span><span class="p">)):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">queque</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">visited_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">neighbor</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="n">visited_nodes</span><span class="p">[</span><span class="n">node</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">queque</span><span class="p">:</span>
                    <span class="n">neighbor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">dist_info</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dist_info</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_info</span><span class="p">[</span><span class="n">node</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">node</span><span class="o">-</span><span class="mi">1</span>
            <span class="n">queque</span> <span class="o">=</span> <span class="n">queque</span> <span class="o">+</span> <span class="n">neighbor</span>
            
    <span class="k">if</span> <span class="n">target_node</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">shortest_path_to_target</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">dist_info</span><span class="p">[</span><span class="n">target_node</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;no path between </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">source_node</span><span class="p">,</span> <span class="n">target_node</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">None</span>
        
        <span class="n">predecessor</span> <span class="o">=</span> <span class="n">target_node</span>
        <span class="k">while</span><span class="p">(</span><span class="n">dist_info</span><span class="p">[</span><span class="n">predecessor</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">shortest_path_to_target</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">predecessor</span><span class="p">)</span>
            <span class="n">predecessor</span> <span class="o">=</span> <span class="n">dist_info</span><span class="p">[</span><span class="n">predecessor</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
            
        <span class="n">shortest_path_to_target</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source_node</span><span class="p">)</span>
        <span class="n">shortest_path_to_target</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">shortest_path_to_target</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dist_info</span>

    

<span class="k">def</span> <span class="nf">pairs_to_graph</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Transform the pairs represented by list into graph.&quot;&quot;&quot;</span>
    <span class="c1"># from scipy.sparse import csr_matrix</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">num_nodes</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">):</span>
        <span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
        <span class="n">graph</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">graph</span>



<span class="k">def</span> <span class="nf">return_csr_matrix_indices</span><span class="p">(</span><span class="n">csr_matrix</span><span class="p">):</span>
    <span class="n">shape_dim1</span><span class="p">,</span> <span class="n">shape_dim2</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">length_range</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="o">.</span><span class="n">indices</span>

    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">length_range</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">csr_matrix</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">_sparsetools</span><span class="o">.</span><span class="n">expandptr</span><span class="p">(</span><span class="n">shape_dim1</span><span class="p">,</span> <span class="n">csr_matrix</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">length_range</span><span class="p">)))</span>



<span class="c1"># deprecated (24/07/2021) -&gt; for scipy shortest distance use</span>
<span class="c1"># def get_shortest_path(predecessors, i, j):</span>
<span class="c1">#     &quot;&quot;&quot;Get the shortest path between two nodes in the graph&quot;&quot;&quot;</span>
<span class="c1">#     path = [j]</span>
<span class="c1">#     k = j</span>
<span class="c1">#     while predecessors[i, k] != -9999:</span>
<span class="c1">#         path.append(predecessors[i, k])</span>
<span class="c1">#         k = predecessors[i, k]</span>
<span class="c1">#     return path[::-1]</span>









</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Stefan GÃ¼ttel, Xinye Chen.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>